<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[测试进度和成本的控制]]></title>
      <url>/2017/10/13/%E6%B5%8B%E8%AF%95%E8%BF%9B%E5%BA%A6%E5%92%8C%E6%88%90%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>项目进度和质量管理</p>
<pre><code>    项目的进度管理是一门艺术，是一个动态的过程，需要不断调度、协调，保证项目的均衡发
展，实现项目整体的动态平衡。项目开始前的计划，对任务的测试需求有一个大体的认识，
但深度不够，进度表可能只是一个时间上的框架，其中一定程度上是靠计划制定者的经验来把握
的。随着时间的推移、测试的不断深入，对任务会有进一步的认识，对很多问题都不再停留在比较
粗的估算上，项目进度表会变得越来越详细、越准确。

    项目的进度管理主要通过里程碑、关键路径的控制并借助工具来实现，同时要把握好进度与质
量、成本的关系，以及充分了解进度的数量和质量的双重特性。
项目进度管理是根据工程项目的进度目标，编制经济合理的进度计划，
并据以检查工程项目进度计划的执行情况，若发现实际执行情况与计划进度不一致，就及时分析原因，
并采取必要的措施对原工程进度计划进行调整或修正的过程。工程项目进度管理的目的就是为了实现最优工期，
多快好省地完成任务。

   项目进度管理是项目管理的一个重要方面，它与项目投资管理、项目质量管理等同为项目管理的
重要组成部分。它是保证项目如期完成或合理安排资源供应，节约工程成本的重要措施之一。
</code></pre><a id="more"></a>
<p>项目进度管理工具</p>
<blockquote>
<ul>
<li><p>日事清是项目进度管理工具。</p>
</li>
<li><p>时间表是项目进度管理工具。</p>
</li>
</ul>
</blockquote>
<p>1.进度的数量和质量的双重特性</p>
<pre><code>   任何一项工作，最开始总是很容易看到进度，就比如盖房子，从无到有，变化是很明显的。可是
越到后来，它的进度越来越不明显。软件测试也是如此，开始测试之初，Bug比较容易发现，但测试
的进展并不是按Bug的数量来计算的，越到后面，Bug越来越难发现。要提高测试进度的质量，将严
重的、关键的问题在第一时间发现出来，这样才不至于在最后阶段使得开发人员要对代码做大规模
的变动，无法保证测试的时间，从而影响软件的质量。这就是测试项目进度的数量和质量的双重特
性，我们在关注进度的同时要把握好这两个特性，在注重进度速度的同时，还要看进度前期的质量。 
</code></pre><p>2.测试进度的管理方法</p>
<pre><code>   首先，尽量利用历史数据，从以前完成过的项目来进行类比分析，以确定质量和进度所存在的某
种数量关系，来控制进度和管理质量。可以采用对进度管理计划添加质量参数的方法，也就是通过
参数调整进度和质量的关系。

   其次，可以采用测试项目进度的度量方法：测试进度S曲线法和缺陷跟踪曲线法。在进度压力之
下，被压缩的时间通常是测试时间，这导致实际的进度随着时间的推移，与最初制定的计划相差越来越远。
而如果有了正式的度量方法，这种情况就很难出现，因为在其出现之前就有可能采取了行动。
</code></pre><p>测试进度S曲线法</p>
<pre><code>   概念：以横坐标为表示时间，纵坐标表示累计完成任务量，绘制一条按计划时间累计完成任务量的S曲线；
然后将工程项目实施过程中各检查时间实际累计完成任务量的S曲线也绘制在同一坐标系中，进行实际进度
与计划进度比较的一种方法。
</code></pre><p>（一）S曲线的绘制方法</p>
<p><span style="color:rgb(51,51,51)">&nbsp;<img src="http://img.blog.csdn.net/20171009180137152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<blockquote>
<ul>
<li>确定单位时间计划完成任务量</li>
<li>计算不同时间累计完成任务量</li>
<li>根据累计完成任务量绘制S曲线</li>
</ul>
</blockquote>
<p>（二）实际进度与计划进度的比较</p>
<p>1.工程项目实际进展状况</p>
<p>　  如果工程实际进展点落在计划S曲线左侧，表明此时实际进度比计划进度超前，如图中的a点；<br>　　如果工程实际进展点落在S计划曲线右侧，表明此时实际进度拖后，如图中的b点；<br>　　如果工程实际进展点正好落在计划S曲线上，则表示此时实际进度与计划进度一致。</p>
<p>2.工程项目实际进度超前或拖后的时间</p>
<p>　　在S曲线比较图中可以直接读出实际进度比计划进度超前或拖后的时间（横坐标）。<br>　　如图所示，△Ta：表示Ta时刻实际进度超前的时间；△Tb表示Tb时刻实际进度拖后的时间。</p>
<p>3.工程项目实际超额或拖欠的任务量</p>
<p>　　在S曲线比较图中也可直接读出实际进度比计划进度超额或拖欠的任务量（纵坐标）。<br>4.后期工程进度预测</p>
<p>　　如果后期工程按原计划速度进行，则可做出后期工程计划S曲线如图中虚线所示，从而可以确定工期拖延预测值△T。</p>
<p>软件测试缺陷跟踪的两个经典分析模型</p>
<pre><code>    缺陷跟踪过程是软件工程中的一个极其重要的过程。本文介绍了如何使用两个经典的分析模型，
来控制缺陷跟踪的过程。这两个模型叫做《活动bug走势图》、《bug打开关闭图》。
另外，在文章中还会提到两个概念：“bug收敛”、“零bug反弹”，具体含义会在介绍中说明。


  活动bug走势曲线上的每个点，表示当天软件中还存在多少个活动bug。这个数字越大，说明软件的
质量越差。而bug打开关闭图中，每天都会有红色、蓝色共两根柱子，表示当天打开、关闭bug的次
数，如果当天这两个数字都很高，说明bug的处理非常活跃，软件非常不稳定。注意，活动bug的单
位是“个”，而打开关闭的单位是“次”，因此我们用线图和柱图分别表示。
</code></pre><p>Bug曲线的三个阶段</p>
<pre><code>   阶段1：测试组对系统开始进行全面测试，打开bug的速度明显高于关闭bug的速度，活动bug数
急速上升，当完成了全部测试用例的执行时，活动bug数达到最大;

   阶段2：开发组全力修复bug，测试组一边验证bug，一边小范围的回归测试，验证bug的周边功
能。这时，关闭bug的速度高于打开bug的速度，活动bug数回落。当活动bug数刚开始回落的时候，
称为“bug收敛”。最终，活动bug会降到一个很低的位置，有时，会达到“零bug ”，不过，这并不
说明项目可以发布。

   阶段3：测试组再次对软件系统进行一次完整的回归测试。在这个过程，还会打开一些bug，但
是，数量很少，这称为“零bug反弹”。完成了这一轮回归之后，软件才真正稳定下来，进入发布候选
过程。
</code></pre><p>如何检测软件质量是否稳定</p>
<pre><code>  如果第二阶段已经开始，但是活动bug仍在继续上升，没有回落，说明打开bug速度仍很高，可能是
第一阶段用例执行还没有完成，或者开发组修复bug速度较低;

如果第二阶段结束，活动bug没有回落到低水平，说明大量的bug还需要修复，软件质量低;

    如果第三阶段，打开、关闭bug的次数很多，说明bug活动频繁，系统稳定性差。
因此，正常的项目测试应该是，活动bug先上扬，再回落，最后在低位小幅振荡，并且打开关闭次数很少。
有了这两个分析模型，我们对项目进度得控制，就更有把握了。
</code></pre><p>bug priority曲线图</p>
<pre><code>  我们大部分人都知道所有的测试执行完成后，都会有测试报告，而测试报告的一个最关键的因素就
是bug曲线图，一般都会有2种曲线：一个是open bug数量的曲线。

   另一个是fixed bug 的数量的曲线。同样也要考虑收敛的问题，这里还有一个相关的曲线也是很重
要的：bug priority曲线图。这里解释下：也就是优先级比较高的bug数量的曲线变化图，一般来说是P1的bug，
如果更细一点也可以有P2的bug。为什么要有这个曲线图呢?一个最重要的目的就是
看测试执行后期，也相当于我们第三轮测试的后期出现多一点的P1的bug(或者接近发布的后期)，
就会对这个质量进行重新评估，也就是会调整计划以及策略去应对这种情况。
</code></pre><p>bug priority曲线图</p>
<pre><code>   优先级比较高的bug数量的曲线变化图，一般来说是P1的bug，如果更细一点也可以有P2的bug。
为什么要有这个曲线图呢?一个最重要的目的就是看测试执行后期，也相当于我们第三轮测试的后期
出现多一点的P1的bug(或者接近发布的后期)，就会对这个质量进行重新评估，也就是会调整计划
以及策略去应对这种情况
</code></pre><p> <span style="font-size:18px">&nbsp;<img src="http://img.blog.csdn.net/20171009180241482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p>BUG预防策略</p>
<pre><code>   BUG预防策略非常简单和容易实现，策略是发现BUG，找出BUG的根源，然后寻找一个方法来预防
类似的BUG在将来出现。这策略并不需要昂贵的花费，但是却可带来极大的额外价值。
</code></pre><p>1).BUG记录</p>
<pre><code>   BUG分析的第一步是记录BUG，值得注意的是记录BUG不应该满足于记录BUG的表面症状。测试的
一个重要职责就是试图发现BUG的根本原因，在测试时不应将产品看作一个黑盒，而应该像开发人员
那样了解产品的内在，包括深入源代码，理解产品的设计和实现
</code></pre><p>2). 利用BUG分析了解开发质量趋势</p>
<pre><code>   BUG预防分析是整个BUG分析过程的核心。这一阶段总结出的实践可以在更广泛的范围内预防潜在的
缺陷。由于分析结果的广泛应用性，分析某个具体BUG的投入将很容易被收回。在这个时候，BUG分
析提供了两个非常重要的参数，一个是缺陷数量的趋势，另一个是缺陷修复的趋势。缺陷趋势就是
将每月新生成的缺陷数、每月被解决的缺陷数和每月遗留的缺陷数标成一个趋势图表。

    一般在项目的开始阶段发现缺陷数曲线会呈上升趋势，到项目中后期被修复缺陷数曲线会趋于上
升，而发现缺陷数曲线应总体趋于下降。同时处于OPEN状态的缺陷也应该总体呈下降趋势，到项目
最后，三条曲线都趋向于零。项目经理可通过持续观察这张图表，确保项目开发健康发展。同时，
通过分析预测项目测试缺陷趋于零的时间，以制定产品质量验收和发布的时间。
</code></pre><p>3)发布BUG分析经验,提高团队成员能力</p>
<pre><code>  BUG分析的价值不仅仅是缺陷的预防，更大的好处是通过记录和分析BUG，项目内的其他开发人员知
道如何发现类似的错误。所以，我们可以通过某个开发人员产生的一个BUG提高整个项目团队的实践
经验，而不仅仅是尽快修正它。这样，因为一个缺陷所浪费的时间也可以转化为收益：确保类似的
错误不会再发生。除了分享项目内的测试知识和经验，BUG分析过程还可以促进开发更好的测试技术
和工具，从而帮助发现类似的BUG。
</code></pre>]]></content>
      
        <categories>
            
            <category> 测试经验文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 项目进度 </tag>
            
            <tag> 质量管理 </tag>
            
            <tag> 成本的控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（八）--T-SQL]]></title>
      <url>/2017/10/08/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89-T-SQL/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>T-SQL</li>
<li>变量</li>
<li>流程控制语句</li>
<li>存储过程</li>
</ul>
</blockquote>
<h3 id="一、T-SQL-transact-sql"><a href="#一、T-SQL-transact-sql" class="headerlink" title="一、T-SQL(transact sql)"></a>一、T-SQL(transact sql)</h3><h4 id="1-数据定义部分（DDL-Data-Definition-Language）"><a href="#1-数据定义部分（DDL-Data-Definition-Language）" class="headerlink" title="(1)数据定义部分（DDL Data Definition Language）"></a>(1)数据定义部分（DDL Data Definition Language）</h4><pre><code>1）create
2）alter
3）drop
</code></pre> <a id="more"></a>
<h4 id="2-数据操作部分（DML-Data-Manipulation-Language）"><a href="#2-数据操作部分（DML-Data-Manipulation-Language）" class="headerlink" title="(2)数据操作部分（DML Data Manipulation Language）"></a>(2)数据操作部分（DML Data Manipulation Language）</h4><pre><code>&lt;pre&gt;`1）insert
2）delete
3）update
4）select
</code></pre><h4 id="3-数据控制部分（DCL-Data-Control-Language）：权限控制"><a href="#3-数据控制部分（DCL-Data-Control-Language）：权限控制" class="headerlink" title="(3)数据控制部分（DCL Data Control Language）：权限控制"></a>(3)数据控制部分（DCL Data Control Language）：权限控制</h4><pre><code>1）grant
2）revoke
</code></pre><h4 id="4-流程控制语句部分"><a href="#4-流程控制语句部分" class="headerlink" title="(4)流程控制语句部分"></a>(4)流程控制语句部分</h4><pre><code>1）begin
2）end
3）if,else
4）else if
5）while
</code></pre><h3 id="2．全局变量（系统已定义）："><a href="#2．全局变量（系统已定义）：" class="headerlink" title="2．全局变量（系统已定义）："></a>2．全局变量（系统已定义）：</h3><pre><code>select @@+变量名
</code></pre><h3 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3. 局部变量"></a>3. 局部变量</h3><blockquote>
<ul>
<li>定义局部变量：declare @+变量名</li>
<li>给局部变量赋值：set @变量名=</li>
<li>输出变量：print @变量名</li>
</ul>
</blockquote>
<h3 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4. 流程控制语句"></a>4. 流程控制语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><pre><code>If 判断条件
Begin
执行语句
End
Else 
Begin 
执行语句
End 
</code></pre><h4 id="wait-for"><a href="#wait-for" class="headerlink" title="wait for"></a>wait for</h4><pre><code>1）Waitfor delay ’00:00:05’ 延迟5秒执行语句
2）waitfor time ’10:17’ 系统时间为10:17时执行语句
</code></pre><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><pre><code>While 判断条件
Begin 
   执行语句
End
</code></pre><h3 id="5-存储过程：实现某种功能，已编译的语句块集合"><a href="#5-存储过程：实现某种功能，已编译的语句块集合" class="headerlink" title="5. 存储过程：实现某种功能，已编译的语句块集合"></a>5. 存储过程：实现某种功能，已编译的语句块集合</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><pre><code>1）提高效率
2）减少网络流量的产生
</code></pre><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><pre><code>1）系统存储过程：sp_存储过程名
2）可拓展存储过程：xp_存储过程名
3）自定义存储过程：自定义
</code></pre><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><pre><code>Creale procedure 存储过程名
（参数）
As
功能语句
</code></pre><h4 id="执行存储过程-exec"><a href="#执行存储过程-exec" class="headerlink" title="执行存储过程 exec"></a>执行存储过程 exec</h4><pre><code>Exec 存储过程名
</code></pre><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><pre><code>Drop procedure 存储过程名

create table userTable(
  userName varchar(10) primary key,
  userPasswd varchar(10),
  userCheckPasswd varchar(10))

create procedure pro_zhuce3
  @username varchar(30),
  @checkpassword1 varchar(30),
  @checkpassword2 varchar(30)
as
declare @number int
set @number=(select COUNT(*) from userTable where userName=@username)
if @number=1
begin
    print &apos;该用户已存在&apos;
end
else if @checkpassword1=@checkpassword2
  begin
    insert into userTable values(@username,@checkpassword1,@checkpassword2)
  end
else
begin
    print &apos;两次密码输出不正确&apos;
end

exec pro_zhuce3 steven123,12345,12345

select * from userTable
</code></pre><hr>
<pre><code>`create procedure pro_denglu1 
@username varchar(30),
@password varchar(30)
as
declare @number int,@code varchar(30)
set @number=(select COUNT(*) from userTable where userName=@username)
set @code=(select userPasswd from userTable where userName=@username)
if @number=1 and @code=@password
begin
    print &apos;登陆成功&apos;
end
else if @number!=1
begin
    print &apos;用户不存在&apos;
end
else
begin
    print &apos;密码错误&apos;
end

exec pro_denglu1 steven4,12345`
</code></pre><hr>
<pre><code>create procedure pro_xiugai2
@username varchar(30),
@password varchar(30),
@newPassword varchar(30)
as 
declare @number int,@code varchar(30)
set @number=(select COUNT(*) from userTable where userName=@username)
set @code=(select userPasswd from userTable where userName=@username)
if @number=1 and @code=@password
begin
    update userTable
    set userPasswd=@newPassword
    where userName=@username
    print &apos;修改成功&apos;
end
else if @number!=1
begin
    print &apos;用户不存在&apos;
end
else
begin
    print &apos;密码错误&apos;
end

exec pro_xiugai2 123123,12345,19931016
</code></pre><hr>
<pre><code>create procedure pro_delete1
@username varchar(30),
@password varchar(30)
as
declare @number int,@code varchar(30)
set @number=(select COUNT(*) from userTable where userName=@username)
set @code=(select userPasswd from userTable where userName=@username)
if @number=1 and @code=@password
begin
    delete from userTable
    where userName=@username
    print &apos;删除成功&apos;
end
else if @number!=1
begin
    print &apos;用户不存在&apos;
end
else
begin
    print &apos;密码错误&apos;
end

exec pro_delete1 &apos;123nine&apos;,123123

select * from userTable
</code></pre><hr>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（七）--函数视图]]></title>
      <url>/2017/10/08/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89-%E5%87%BD%E6%95%B0%E8%A7%86%E5%9B%BE/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>系统函数</li>
<li>视图</li>
<li>索引</li>
</ul>
</blockquote>
<h3 id="1-系统函数"><a href="#1-系统函数" class="headerlink" title="1.系统函数"></a>1.系统函数</h3><h4 id="1-（）数学函数"><a href="#1-（）数学函数" class="headerlink" title="(1) （）数学函数"></a>(1) （）数学函数</h4><ul>
<li>Abs()          绝对值<em>   Floor()        向下取整</em>   Ceiling()     向上取整</li>
<li>Sin()     返回指定角度（以弧度为单位）的三角正弦值*   Pi()    圆周率</li>
<li>Rand()      随机数*   Sqrt()        开方</li>
<li>Square()   平方<a id="more"></a>
<h4 id="（2）字符函数"><a href="#（2）字符函数" class="headerlink" title="（2）字符函数"></a>（2）字符函数</h4></li>
</ul>
<p>1）Ascii（）      ：ASCII代码值 </p>
<p>2）Unicode（）：返回输入表达式的第一个字符的整数值 </p>
<p>3）Char（）：将int ASCII代码转换为字符 </p>
<p>4）Left（’abc’, 2）：返回字符串中从左边开始指定个数的字符 </p>
<p>5）Right（’abc’, 2）：返回字符串中从右边开始指定个数的字符 </p>
<p>6）Ltrim（’     abc’）：返回删除了左边空格的字符表达式 </p>
<p>7）Rtrim（’abc     ’）：返回删除了右边空格的字符表达式 </p>
<p>8）Substring（’abcdef’ , 3 , 2）：</p>
<ul>
<li>’abcdef’表示需要截取的字符串</li>
<li>3表示从第三个字符开始截取</li>
<li>2表示截取字符串的长度</li>
</ul>
<p>9）Replace（’abcdef’ , ’c’ , ’o’）=abodef </p>
<p>10）Len（）：返回字符表达式中的字符数 </p>
<p>11）Cast（2 as varchar(5)）：转换数据类型 </p>
<p>12）Convert（varchar(10),2）：转换数据类型 </p>
<p>13）Reverse（）：反转输出</p>
<h4 id="（3）-日期函数"><a href="#（3）-日期函数" class="headerlink" title="（3）   日期函数"></a>（3）   日期函数</h4><pre><code>1）Getdate（）：获取系统时间
2）Year（）：获取时间中的年份
3）Month（）：获取时间中的月份
4）Day（）：获取时间中的日期
5）Select convert (time, getdate())：或许系统中的时间
6）Datediff（时间单位,时间1,时间2）：求时间1与时间2以指定时间单位相减的差
7）Dateadd（时间单位,时间1,时间2）：求时间1与时间2以指定时间单位相加的和
</code></pre><h4 id="2-视图（虚拟表：不存储数据，但会开辟空间存储视图表结构）"><a href="#2-视图（虚拟表：不存储数据，但会开辟空间存储视图表结构）" class="headerlink" title="2.视图（虚拟表：不存储数据，但会开辟空间存储视图表结构）"></a>2.视图（虚拟表：不存储数据，但会开辟空间存储视图表结构）</h4><h4 id="（1）创建视图"><a href="#（1）创建视图" class="headerlink" title="（1）创建视图"></a>（1）创建视图</h4><p>Create view 视图名1 </p>
<p>As </p>
<p>Select * from 表名2</p>
<h4 id="（2）修改数据"><a href="#（2）修改数据" class="headerlink" title="（2）修改数据"></a>（2）修改数据</h4><blockquote>
<ul>
<li>来自一个表，可以随意修改</li>
<li>来自多个表，则不能随意修改</li>
</ul>
</blockquote>
<h4 id="（3）作用"><a href="#（3）作用" class="headerlink" title="（3）作用"></a>（3）作用</h4><blockquote>
<ul>
<li>安全</li>
<li>方便操作</li>
<li>提高效率</li>
</ul>
</blockquote>
<h4 id="（4）修改视图"><a href="#（4）修改视图" class="headerlink" title="（4）修改视图"></a>（4）修改视图</h4><p>Alter view 视图名1 </p>
<p>As </p>
<p>Select * from 表名2</p>
<h3 id="3-系统对象sysobjects"><a href="#3-系统对象sysobjects" class="headerlink" title="3.系统对象sysobjects"></a>3.系统对象sysobjects</h3><h3 id="4-索引：以一列或多列为标志，提高表的查询效率"><a href="#4-索引：以一列或多列为标志，提高表的查询效率" class="headerlink" title="4.索引：以一列或多列为标志，提高表的查询效率"></a>4.索引：以一列或多列为标志，提高表的查询效率</h3><blockquote>
<ul>
<li>聚集索引：索引存储位置与数据存储位置在同一页面（例：通讯录）</li>
<li>非聚集索引：索引存储位置与数据存储位置不在同一页面（例：字典）</li>
<li>创建非聚集索引<br>  Create index 索引名<br>  On 表名（列名）</li>
<li>创建聚集索引<br>  Create clustered index 索引名<br>  On 表名（列名）</li>
<li>创建唯一索引<br>  Create unique index 索引名<br>  On 表名（列名）</li>
<li>查询索引<br>  Exec sp_helpindex 表名</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 视图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（六）--查询语句]]></title>
      <url>/2017/10/08/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>联合查询</li>
</ul>
</blockquote>
<p>use student</p>
<p>–建表<br>create table class_A(<br>id int primary key,<br>name varchar(50),<br>sex char(50),<br>course varchar(50),<br>score float<br>)</p>
<a id="more"></a>
<p>–建表<br>create table course(<br>cno int primary key,<br>cname varchar(50),<br>number int<br>)<br>–插入数据<br>insert into course values (1,’java’,2)<br>insert into course values (2,’python’,1)<br>insert into course values (3,’Linux’,1)<br>insert into course values (4,’oracle’,1)<br>insert into course values (5,’music’,1)<br>insert into course values (6,’actor’,1)<br>insert into course values (7,’singer’,1)<br>–插入数据<br>insert into class_A values(1,’刘备’,’male’,’java’,85)<br>insert into class_A values(2,’周瑜’,’male’,’python’,76.56)<br>insert into class_A values(3,’貂蝉’,’female’,’Linux’,99)<br>insert into class_A values(4,’关羽’,’male’,’oracle’,69.66)<br>insert into class_A values(5,’文章’,’male’,’java’,55)<br>insert into class_A values(6,’玛丽’,’female’,’music’,45)<br>insert into class_A values(7,’麦当娜’,’female’,’actor’,99)<br>insert into class_A values(8,’vava’,’female’,’singer’,75)</p>
<p>insert into class_A values(10,’lomo’,’’,’’,’’)<br>insert into course values (9,’’,’’)</p>
<p>####1.联合查询<br>(1)笛卡尔积<br>    select * from 表名1， 表名2 </p>
<p>####(2)内联<br>1)<br>    select <em> from 表名1 inner join 表名2<br>    on 表名1.列名1=表名2.列名2<br>2)<br>    select </em> from 表名1,表名2<br>    where表名1.列名1=表名2.列名2</p>
<p>####(3)外联<br>       1)左联：select <em> from 表1 left join 表名2 on 表名1.列名1=表2.列名2<br>       2)右联：select </em> from 表1 right join 表名2 on 表名1.列名1=表2.列名2<br>       3)以左联解释：以左表为主，右表为辅，若左表数据多，缺少的数据以null填充；<br>    若左表数据少，多余的数据不显示</p>
<p>####(4)全联：<br>    两张表全部显示，若不存在数据关联，缺少的数据以null填充<br>    select * from 表名1 full join 表名2<br>    on 表名1.列名1=表名2.列名2</p>
<p>####(5)自联：<br>    Select * from 旧表名 新表名1，旧表名 新表名2<br>    where 新表名1.列名1=新表名2.列名2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">--联合查询</div><div class="line">--笛卡尔积</div><div class="line">select * from class_A,course</div><div class="line"></div><div class="line">--内联</div><div class="line">--方法一</div><div class="line">select * from class_A,course</div><div class="line">where class_A.course=course.cname</div><div class="line">--方法二</div><div class="line">select * from class_A inner join course</div><div class="line">on class_A.course=course.cname</div><div class="line"></div><div class="line">--外联</div><div class="line">--左联</div><div class="line">select * from class_A left join course on </div><div class="line">class_A.course = course.cname</div><div class="line"></div><div class="line">--右联</div><div class="line">select * from class_A right join course on</div><div class="line">class_A.course = course.cname</div><div class="line"></div><div class="line">--全联</div><div class="line">select * from class_A full join course on</div><div class="line">class_A.course = course.cname</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div></pre></td><td class="code"><pre><div class="line">use student</div><div class="line"></div><div class="line">学生信息表</div><div class="line">create table student_info(</div><div class="line">student_id int primary key,</div><div class="line">student_name varchar(50),</div><div class="line">student_sex char(50),</div><div class="line">born_date datetime,</div><div class="line">class_no int,</div><div class="line">tele_number int,</div><div class="line">ru_date datetime,</div><div class="line">address text,</div><div class="line">commet varchar(50)</div><div class="line">)</div><div class="line"></div><div class="line">课程信息表</div><div class="line">create table course_info(</div><div class="line">course_no int primary key,</div><div class="line">course_name varchar(50),</div><div class="line">course_type varchar(50),</div><div class="line">course_start int,</div><div class="line">course_time int,</div><div class="line">course_score int</div><div class="line">)</div><div class="line"></div><div class="line">--成绩信息表</div><div class="line">create table result_info(</div><div class="line">student_id int ,</div><div class="line">course_no int ,</div><div class="line">result int</div><div class="line">)</div><div class="line"></div><div class="line">--班级信息表</div><div class="line">create table class_info(</div><div class="line">class_no int primary key,</div><div class="line">class_name varchar(50) ,</div><div class="line">director varchar(50),</div><div class="line">profession varchar(50) </div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">--select语句中，一个字段前加上单引号字符串，对后面的字段进行说明。</div><div class="line">select student_name,&apos;家庭住址&apos;,address from student_info</div><div class="line"></div><div class="line"></div><div class="line">select student_name, year(GETDATE())-year(born_date) as 年龄 from student_info</div><div class="line"></div><div class="line"></div><div class="line">--discinct 去重复项记录</div><div class="line">select distinct class_no from student_info</div><div class="line"></div><div class="line">--列出女性学生的姓名的家庭住址</div><div class="line">select student_name,&apos;家庭住址&apos; as 描述,address </div><div class="line">from student_info</div><div class="line">where student_sex = &apos;女&apos;</div><div class="line"></div><div class="line">--列出2014年以后出生的学生的基本信息</div><div class="line">select * from student_info</div><div class="line">where year(born_date) &gt;&apos;2014&apos;</div><div class="line"></div><div class="line">select * from student_info</div><div class="line">where born_date &gt;&apos;2014-12-31&apos;</div><div class="line"></div><div class="line">--列出广州的男同学的姓名、电话和地址</div><div class="line">select student_name,tele_number,address </div><div class="line">from student_info</div><div class="line">where student_sex=&apos;男&apos;</div><div class="line">and address like &apos;广州%&apos;</div><div class="line"></div><div class="line">--列出电话开头是136的学生基本信息</div><div class="line"></div><div class="line">select * from student_info</div><div class="line">where tele_number like &apos;136%&apos;</div><div class="line"></div><div class="line">--列出所有不是2岁的同学的姓名、性别、出生年月</div><div class="line">select student_name,student_sex,born_date </div><div class="line">from student_info</div><div class="line">where (YEAR(GETDATE())-YEAR(born_date))!=2</div><div class="line"></div><div class="line">--特殊运算符使用</div><div class="line">--[NOT]between...and...</div><div class="line">--列出所有2-3岁之间的同学的姓名、性别、出生年月</div><div class="line"></div><div class="line">select student_name,student_sex,born_date </div><div class="line">from student_info</div><div class="line">where (YEAR(GETDATE())-YEAR(born_date)) not between 2 and 3 </div><div class="line"></div><div class="line">select student_name,student_sex,born_date </div><div class="line">from student_info</div><div class="line">where (YEAR(GETDATE())-YEAR(born_date))  between 2 and 3 </div><div class="line"></div><div class="line">--IS NULL 判断表达式的值是否为空值</div><div class="line">--列出所有注释内容为空的同学的信息</div><div class="line"></div><div class="line">select * from student_info</div><div class="line">where commet is null</div><div class="line"></div><div class="line">--IS NOT NULL 不为空</div><div class="line">select * from student_info</div><div class="line">where commet is not null</div><div class="line"></div><div class="line">/*</div><div class="line">  IN 可以指定一个值表，值表中列出所有可能的值</div><div class="line">  当表达式与任意一个值进行匹配，成功返回TRUE</div><div class="line">  失败返回FALSE</div><div class="line">*/</div><div class="line"></div><div class="line">--列出所有2000001和2000002班的学生的学号、姓名、性别</div><div class="line">select student_id,student_name,student_sex </div><div class="line">from student_info</div><div class="line">where class_no in (2000001,2000002)</div><div class="line"></div><div class="line">select student_id,student_name,student_sex </div><div class="line">from student_info</div><div class="line">where class_no =2000001 or class_no =2000002</div><div class="line"></div><div class="line">--NOT IN </div><div class="line">--列出不是2000001，也不是2000002班的学生的学号、姓名、性别</div><div class="line">select student_id,student_name,student_sex </div><div class="line">from student_info</div><div class="line">where class_no NOT in (2000001,2000002)</div><div class="line"></div><div class="line">--ORDER BY  排序</div><div class="line">--ASC 顺序    DESC倒序</div><div class="line">/*</div><div class="line">ORDER BY _column1, _column2;  _column1升序，_column2升序 </div><div class="line"> </div><div class="line">ORDER BY _column1, _column2 DESC;  _column1升序，_column2降序 </div><div class="line"> </div><div class="line">ORDER BY _column1 DESC, _column2 ;  _column1降序，_column2升序 </div><div class="line"> </div><div class="line">ORDER BY _column1 DESC, _column2 DESC;  _column1降序，_column2降序 */</div><div class="line"></div><div class="line">--能联排序</div><div class="line"></div><div class="line"></div><div class="line">--列出2015年以后入学的学生的姓名、学号、性别</div><div class="line"></div><div class="line">select student_name,student_id,student_sex from student_info</div><div class="line">where YEAR(ru_date)  &gt; 2015</div><div class="line">order by ru_date desc, student_id</div><div class="line"></div><div class="line">--group by 对查询结果进行分组，通常和聚合函数一起使用</div><div class="line"></div><div class="line">--统计各个班级的学生总人数</div><div class="line"></div><div class="line">select  class_no,count(student_id) 班级人数 </div><div class="line">	from student_info</div><div class="line">		group by class_no</div><div class="line"></div><div class="line">--统计男女各自的总人数 和平均年龄</div><div class="line"></div><div class="line">select COUNT(student_id) 总人数,</div><div class="line">AVG(YEAR(getdate())-year(born_date)) 平均年龄</div><div class="line">	from student_info</div><div class="line">		group by student_sex</div><div class="line"></div><div class="line">--HAVING 筛选结果表</div><div class="line">--WHERE子句 与 HAVING子句的区别</div><div class="line">--WHERE子句作用对象是表，从表中选择出满足筛选条件的记录 </div><div class="line">--HAVING子句作用对象是组,从组中选择出满足筛选条件的记录</div><div class="line"></div><div class="line">--将人数大于2的班级总人数显示出来</div><div class="line">select class_no 班级, COUNT(student_id) 总人数</div><div class="line">	from student_info</div><div class="line">	group by class_no</div><div class="line">	having COUNT(student_id)&gt;2</div><div class="line"></div><div class="line">--基于多表的联合查询</div><div class="line">/*</div><div class="line">连接查询</div><div class="line">是关系数据库中最主要的查询，主要包括内连接、外连接和交叉连接等。</div><div class="line">通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，</div><div class="line">也是它区别于其它类型数据库管理系统的一个标志。 在关系数据库管理系统中，</div><div class="line">表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。</div><div class="line">当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。</div><div class="line">连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。</div><div class="line">为不同实体创建新的表，然后通过连接进行查询。</div><div class="line"></div><div class="line"></div><div class="line">联合查询是可合并多个相似的选择查询的结果集。</div><div class="line">等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，</div><div class="line">使用谓词为UNION或UNION ALL。</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">select * from class_info</div><div class="line">select * from course_info</div><div class="line">select * from result_info</div><div class="line">select * from student_info</div><div class="line"></div><div class="line"></div><div class="line">--等值链接 </div><div class="line">select class_info.*,student_info.* </div><div class="line"> from class_info,student_info</div><div class="line">  where class_info.class_no=student_info.class_no</div><div class="line">  </div><div class="line">--自然连接(自然连接的表达式中，各表主键和外键进行等值连接) </div><div class="line">select student_info.class_no,class_name,director,profession,student_id,</div><div class="line">student_name,student_sex,born_date,tele_number,ru_date,address,commet</div><div class="line"> from class_info,student_info</div><div class="line">  where student_info.class_no=class_info.class_no</div><div class="line"> </div><div class="line">/*</div><div class="line">注意:查询多个表是列必须明确,任何重复的列名都必须用表明限定</div><div class="line">     所有列名如何都用表明限定，则可提高查询的可读性</div><div class="line">     如果使用表的别名， 则进一步提高可读性</div><div class="line">*/</div><div class="line"></div><div class="line">--采用自身连接，查询不同课程相同成绩的学生的	学号 课程号 和成绩</div><div class="line"></div><div class="line">select a.student_id,a.course_no,b.course_no,a.result </div><div class="line"> from  result_info a,result_info b</div><div class="line">  where a.result=b.result</div><div class="line">   and a.course_no!=b.course_no</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">--join    on </div><div class="line">--</div><div class="line"></div><div class="line">--子查询</div><div class="line">--查询小强所在的班级名称</div><div class="line"></div><div class="line">select class_info.class_name from student_info,class_info</div><div class="line">where student_info.class_no=class_info.class_no</div><div class="line">and student_name like &apos;%小强%&apos;</div><div class="line"></div><div class="line"></div><div class="line">select class_name from class_info</div><div class="line">	where class_no=(</div><div class="line">		select class_no from student_info </div><div class="line">			where student_name like &apos;%小强%&apos;)</div><div class="line">			</div><div class="line">--</div><div class="line">/*</div><div class="line">   连接和子查询的区别</div><div class="line">   1.连接的结果可以是合并多个表；子查询的结果只能来自一个表</div><div class="line">   </div><div class="line">*/</div><div class="line"></div><div class="line">--使用IN 、NOT IN 的子查询</div><div class="line"></div><div class="line">--insert /update/delete 的子查询</div><div class="line"></div><div class="line">/*  使用比较运算符的子查询(ALL/ANY)</div><div class="line">    ALL 表达式要与子查询结果的所有值进行比较 (成功返回TRUE，否则返回FALSE)</div><div class="line">    ANY 表达式与子查询结果要满足比较的关系 (成功返回TRUE，否则返回FALSE) */</div><div class="line"> </div><div class="line">--使用EXISTS的子查询用于测试结果是否为空表,不为空返回TRUE，否则返回FALSE</div><div class="line">--NOT EXISTS刚好相反</div><div class="line"></div><div class="line">--使用UNION运算符组合多个表的结果</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（五）--操作符聚合函数]]></title>
      <url>/2017/10/08/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>算术运算符</li>
<li>逻辑运算符</li>
<li>比较运算符</li>
<li>聚合函数</li>
</ul>
</blockquote>
<p>算术运算符（+ - <em> / ）<br>select score</em>2 as 成绩翻倍 from class_A </p>
<p>update  class_A<br>set score=score+20<br>where score<70 <!----more-----=""><br>update  class_A<br>set score=score-20<br>where score&gt;70</70></p>
<p>update  class_A<br>set score=score/2<br>where score&gt;70</p>
<p>逻辑运算符(and/or/between A and B )</p>
<p>select <em> from class_A<br>select </em> from class_A where score &gt;=80 and sex = ‘male’<br>select <em> from class_A where score &gt;=80 or sex = ‘male’<br>select </em> from class_A where score between 60 and 80</p>
<p>比较运算符（&lt; &gt; &lt;= &gt;= &lt;&gt; != = ）</p>
<p>介词查询 in（a,b…）：在a、b中查询</p>
<p>Select * from class_A<br>Where score in(60,80)</p>
<p>去除重复值 distinct<br>Select distinct 列名 from 表名</p>
<p>查询前N条数据 top</p>
<p>Select top 2 * from class_A</p>
<p>查询前百分比条数据 top percent<br>Select top 20 percent * from class_A</p>
<p>查询后N条数据<br>Select top 4 * from class_A<br>Where score not in<br>(select top 3 score from class_A)</p>
<p>模糊查询like<br>Select <em> from class_A where name like ‘%娜%’<br>Select </em> from class<em>A where name like ‘文</em>‘<br>Select <em> from class_A where name like ‘[文][章]’<br>Select </em> from class_A where name like ‘[李%]’<br>Select * from class_A where name like ‘%娜%’</p>
<p>%  表示任意通配<br><em>  表示一个字符通配<br>[] 表示集合（[a-z]、[123]、[中山]、[中][山]）<br>    [中山]等价于[中][山]<br>    []中文要使用%或</em></p>
<p>排序order by（默认为升序）<br>升序<br>Select <em> from class_A<br>Order by score<br>降序<br>Select </em> from class_A<br>Order by score desc</p>
<p>分组group by<br>在分组时，查询字段必须与分组的字段一致或者查询条件使用的是聚合函数</p>
<p>聚合函数<br>（1）统计函数<br>1）Count（）：统计总数<br>2）Max（）：最大值<br>3）Min（）：最小值<br>4）Avg（）：平均值<br>5）Sum（）：总和<br>6）Var（）：方差</p>
<p>使用having进行分组筛选<br>Select 列名1,聚合函数 from 表名<br>Group by 列名1<br>Having 聚合函数条件</p>
<p>select sum(score) as 总分 from class_A<br>select count(name) as 总人数 from class_A<br>select max(score) as 最高分 from class_A<br>select min(score) as 最低分 from class_A<br>select avg(score) as 平均分 from class_A</p>
<p>select name,AVG(score)  from class_A group by name,score<br>having  score &gt; 60</p>
<p>select name,avg(score)  from class_A group by sex,name<br>having avg(score) &lt;68 and sex=’male’</p>
<p>select avg(score) as 平均分 from class_A where sex=’male’<br>select avg(score) as 平均分 from class_A where sex=’female’</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 聚合函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（四）--约束]]></title>
      <url>/2017/10/02/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BA%A6%E6%9D%9F/</url>
      <content type="html"><![CDATA[<h2 id="SQLServer-约束"><a href="#SQLServer-约束" class="headerlink" title="SQLServer - 约束"></a>SQLServer - 约束</h2><pre><code>主要是为了保证数据库中的数据一致性、有效性、准确性，
从而提高了数据库中数据的正确性
</code></pre><a id="more"></a>
<h3 id="一、约束的分类"><a href="#一、约束的分类" class="headerlink" title="一、约束的分类"></a>一、约束的分类</h3><h4 id="在SQLserver中，约束分三种不同类型"><a href="#在SQLserver中，约束分三种不同类型" class="headerlink" title="在SQLserver中，约束分三种不同类型"></a>在SQLserver中，约束分三种不同类型</h4><blockquote>
<ul>
<li>1.实体约束       实提约束是关于行的。比如某一行的值就不允许出现在其他行，比如主键</li>
<li>2.域约束       域约束是关于列的。对于所有行，某一列是有那些约束，比如check约束</li>
<li>3.参照完整性约束       如果某列的值必须与其他列匹配，就需要一个参照完整性约束，比如外键</li>
</ul>
</blockquote>
<h3 id="二、约束命名"><a href="#二、约束命名" class="headerlink" title="二、约束命名"></a>二、约束命名</h3><pre><code>SQLServer在我们不提供名称时，会自动创建名称，但是由系统自动创建的名称并不是特别有用。
为了能够一眼看上去就知道这个约束是用来干什么的，我们应该使用一种简单明了的短语来进行命名。
例如要确保某一列电话号码格式正确的约束，我们可以使用命名CK_Customers_PhoneNo这样的短语来命名。
</code></pre><h3 id="三、键约束"><a href="#三、键约束" class="headerlink" title="三、键约束"></a>三、键约束</h3><blockquote>
<ul>
<li>主键约束（Primary Key constraint）：要求主键列数据唯一，并且不允许为空。</li>
<li>唯一约束（Unique constraint）：要求该列唯一，允许为空，但只能出现一个空值。</li>
<li>检查约束（Check constraint）：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。</li>
<li>默认约束（Default constraint）：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。</li>
<li>外键约束（Foreign Key constraint）：用于在两个表之间建立关系，需要指定引用主表的哪一列。</li>
<li>*不为空约束（Not Null）</li>
</ul>
</blockquote>
<h4 id="添加语法："><a href="#添加语法：" class="headerlink" title="添加语法："></a>添加语法：</h4><pre><code>    ALTER TABLE 表名
    ADD CONSTRAINT 约束名 约束 类型 具体的约束说明
    上述语法表示修改某个表，添加某个约束。其中，约束名的命名规则推荐
采用“约束类型_约束字段”这样的形式。
</code></pre><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre><code>添加主键约束（将stuNo设为主键）：
ALTER TABLE stuInfo
ADD CONSTRAINT PK_stuNo PRIMARY KEY (stuNo)

添加唯一约束（身份证号唯一）：
ALTER TABLE stuInfo
ADD CONSTRAINT UQ_stuID UNIQUE (stuID)

添加默认约束（如果地址不填，默认为“地址不详”）：
ALTER TABLE stuInfo
ADD CONSTRAINT DF_stuAddress DEFAULT (&apos;地址不详&apos;) FOR stuAddress

添加检查约束（要求年龄只能在 15~40岁之间）
ALTER TABLE stuInfo
ADD CONSTRAINT CK_stuAge CHECK(stuAge BETWEEN 15 AND 40)

添加外键约束（主表 stuInfo 和从表 stuGrade 建立关系，关联字段为 stuNo ）：
ALTER TABLE stuGrade
ADD CONSTRAINT FK_stuNo
FOREIGN KEY (stuNo) REFERENCES stuInfo(stuNo)
GO


* * *
</code></pre><h4 id="删除语法："><a href="#删除语法：" class="headerlink" title="删除语法："></a>删除语法：</h4><pre><code>ALTER TABLE 表名
DROP CONSTRAINT 约束名
</code></pre><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><pre><code>删除stuInfo表中地址默认约束的语句：
ALTER TABLE stuInfo
DROP CONSTRAINT DF_stuAddress
</code></pre><h4 id="删除外键约束注意事项："><a href="#删除外键约束注意事项：" class="headerlink" title="删除外键约束注意事项："></a>删除外键约束注意事项：</h4><p>对于存在外键约束的表，如果进行删除非空的外键，可能会出现错误。</p>
<blockquote>
<ul>
<li>如果在 FOREIGN KEY 约束的列中输入非 NULL 值，则此值必须在被引用的列中存在，否则将返回违反外键约束的错误信息。</li>
<li>FOREIGN KEY 约束应用于前面所讲的列，除非指定了源列。</li>
<li>FOREIGN KEY 约束仅能引用位于同一服务器上的同一数据库中的表。数据库间的引用完整性必须通过触发器实现。有关更多信息，请参见 CREATE TRIGGER。</li>
<li>FOREIGN KEY 可以引用同一表中的其它列（自引用）。</li>
<li>列级 FOREIGN KEY 约束的 REFERENCES 子句仅能列出一个引用列，且该列必须与定义约束的列具有相同的数据类型。</li>
<li>表级 FOREIGN KEY 约束的 REFERENCES 子句中引用列的数目必须与约束列列表中的列数相同。每个引用列的数据类型也必须与列表中相应列的数据类型相同。</li>
<li>如果 timestamp 类型的列是外键或被引用键的一部分，则不能指定CASCADE。</li>
<li>可以在相互间具有引用关系的表上组合使用 CASCADE 和 NO ACTION。如果 SQL Server 遇到 NO ACTION，将终止执行语句并回滚相关的 CASCADE 操作。当 DELETE 语句导致 CASCADE 和 NO ACTION 组合操作时，在 SQL Server 检查 NO ACTION 操作之前将执行所有 CASCADE 操作。</li>
<li>一个表最多可包含 253 个 FOREIGN KEY 约束。</li>
<li>对于临时表不强制 FOREIGN KEY 约束。</li>
<li>每个表在其 FOREIGN KEY 约束中最多可以引用 253 个不同的表。</li>
<li>FOREIGN KEY 约束只能引用被引用表的 PRIMARY KEY 或 UNIQUE 约束中的列或被引用表上 UNIQUE INDEX 中的列。</li>
</ul>
</blockquote>
<pre><code>* * *
</code></pre><p>   –创建不为空约束的方法一<br>alter table class_A<br>alter column name varchar(50) not null</p>
<p>–创建不为空约束的方法二<br>create table test_520shq(<br>id int,<br>manager_name varchar(50) not null,<br>phoneNo int<br>)</p>
<p>验证约束: insert into test_520shq values(1,null,’552222’)</p>
<hr>
<p>drop table test_520shq_D</p>
<p>select * from test_520shq</p>
<p>create table test_520shq_A(<br>id int,<br>java_name varchar(50),<br>phoneNo int<br>)</p>
<p>–创建主键约束方法一<br>alter table test_520shq_A<br>alter column id int not null<br>alter table test_520shq_A<br>add constraint pk_test520shqID primary key(id)</p>
<p>–创建主键约束方法二<br>create table test_520shq_B(<br>id int primary key,<br>net_name varchar(50),<br>phoneNo int<br>)</p>
<p>–创建主键约束方法三<br>create table test_520shq_C(<br>id int,<br>net_name varchar(50),<br>phoneNo int,<br>constraint pk_id primary key(id)<br>)</p>
<p>–查询约束<br>exec sp_helpconstraint test_520shq_C</p>
<p>–删除约束<br>alter table test_520shq_C<br>drop constraint pk_id</p>
<p>–检查约束方法一<br>create table test_520shq_D(<br>id int primary key,<br>name varchar(50),<br>phone_No bigint check (phone_No&gt;9999999999 and phone_No&lt;100000000000)<br>)</p>
<p>验证约束: insert into test_520shq_D values (1,’tom’,138877905089)</p>
<p>–检查约束方法二<br>create table test_520shq_E(<br>id int primary key,<br>name varchar(50),<br>phone_No bigint<br>)</p>
<p>alter table test_520shq_E<br>add constraint ck_phoneNo check(phone_No&gt;9999999999 and phone_No&lt;100000000000)</p>
<p>execute sp_helpconstraint test_520shq_E</p>
<p>alter table test_520shq_E<br>drop constraint ck_phoneNo</p>
<p>drop table test_520shq_E</p>
<p>–检查约束方法三<br>create table test_520shq_E(<br>id int primary key,<br>name varchar(50),<br>phone_No bigint,<br>constraint ck_phone_No check(phone_No&gt;9999999999 and phone_No&lt;100000000000)<br>)</p>
<p>–创建唯一约束方法一<br>create table test_520shq_F(<br>logo_name varchar(50) unique(logo_name)<br>)</p>
<p>验证约束:insert into test_520shq_F values (null)<br>–检查约束方法二<br>create table test_520shq_E(<br>id int primary key,<br>name varchar(50),<br>phone_No bigint<br>)</p>
<p>alter table test_520shq_E<br>add constraint ck_phoneNo check(phone_No&gt;9999999999 and phone_No&lt;100000000000)</p>
<p>execute sp_helpconstraint test_520shq_E</p>
<p>alter table test_520shq_E<br>drop constraint ck_phoneNo</p>
<p>drop table test_520shq_E</p>
<p>–检查约束方法三<br>create table test_520shq_E(<br>id int primary key,<br>name varchar(50),<br>phone_No bigint,<br>constraint ck_phone_No check(phone_No&gt;9999999999 and phone_No&lt;100000000000)<br>)</p>
<p>–创建唯一约束方法一<br>create table test_520shq_F(<br>logo_name varchar(50) unique(logo_name)<br>)</p>
<p>验证约束:insert into test_520shq_F values (null)</p>
<p>–创建唯一约束方法二<br>alter table goods<br>add constraint uq_goodsprice unique(goods_price)</p>
<p>–创建唯一约束方法三<br>create table student3(<br>student3_age int,<br>student3_name varchar(10),<br>constraint uq_student3_age unique(student3_age)</p>
<p>–默认约束<br>–第一种方法<br>create table student4(<br>student_sex char(4) default ‘男’<br>)<br>验证: insert into student3 values (default)<br>–第二种方法<br>alter table goodschart<br>add constraint de_goodsprice default(500) for goodsprice</p>
<p>–外键约束<br>–在创建外键时必须分析出参照表和被参照表<br>create table student10(<br>student_id int,<br>student_name varchar (10),<br>student_age int<br>)<br>insert into student10 values(3,’张三’,12)<br>create table score(<br>student_id int,<br>score int<br>)</p>
<p>外键加在参照表上<br>在创建外键时，必须要求被参照表中的被参照字段设置主键<br>被参照表中的student_id必须添加主键<br>添加外键语法:<br>方法一:不为空约束加上主键约束加上如下约束<br>alter table参照表名<br>add constraint 约束名 foreign key（参照表的字段名）references 被参照表<br>注意：当使用该种方法进行添加进行添加外键时，<br>必须要求被参照表中的参照字段设置主键</p>
<p>alter table student10<br>alter column student_id int not null<br>alter table student10<br>add constraint pk_studentid1 primary key(student10_id)<br>alter table score<br>add constraint fk_studentid foreign key(student_id)references student10</p>
<p>方法2:<br>creat table 参照表名<br>（<br>字段名（被参照表得） foreign key references 被参照表名<br>）<br>方法3：<br>create table 参照表名<br>（<br>字段名<br>Constraint fk_约束名 foreign key(字段名)<br>）</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 约束 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Linux 学习（四）]]></title>
      <url>/2017/09/30/%E5%8E%9F-Linux-%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr>
<p>##Linux进程</p>
<p>1.进程<br>进程：可执行应用程序执行后产生的对应的进程，重量级；进程是由一个线程或多个线程构成；</p>
<p>线程：是计算机中的最小单位，轻量级（依赖和物理性是独立存在的）、损耗较低</p>
<p>假设进程1是由1、2线程组成；进程2是由2、3线程组成；<br>当进程1启动后，进程2则需等待进程1执行完毕，资源释放后，方可执行；<br>而当进程1如果一直都不释放资源，则容易造成死锁；</p>
<p>Zombie僵尸进程：<br>当存在很多僵尸进程说明什么问题：说明模块和模块之间的结构有问题（代码中只写了调用，没有写回收）；<br><a id="more"></a></p>
<hr>
<p>Ps –ef—-查询静态进程监控<br>Kill 进程号—-结束进程<br>Kill -9 进程号—-强制结束进程<br>Ps –ef|pgrep “httpd”—-查询httpd的端口号</p>
<hr>
<p>Top—查询（动态）进程<br>{Load average：系统当前负载资源；<br>Tasks：进程数、zombie僵尸进程；<br>Id ：空闲的<br>Mem：内存；buffer：缓存<br>Swap：交换分区<br>在top状态下，输入u：用户；显示指定的用户进程；<br>输入q：表示退出top状态；</p>
<hr>
<p>查询进程端口：netstat –ano<br>Bash csh ksh tcsh<br>更改shell：chsh –s 目标</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">root目录或宿主目录</td>
</tr>
<tr>
<td style="text-align:left">！</td>
<td style="text-align:left">表示非</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:left">普通链接或者邮箱标识符</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">注释</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">变量</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取模</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">表示不在什么范围之中</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">表示与</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">表示统配</td>
</tr>
<tr>
<td style="text-align:left">（）</td>
<td style="text-align:left">表示函数</td>
</tr>
<tr>
<td style="text-align:left">-+*/</td>
<td style="text-align:left">表示运算符</td>
</tr>
<tr>
<td style="text-align:left">**</td>
<td style="text-align:left">表示幂运算</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">拖逸符</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">表示路径</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">表示枚举</td>
</tr>
<tr>
<td style="text-align:left">[表达式]</td>
<td style="text-align:left">表示的是条件逻辑判定</td>
</tr>
<tr>
<td style="text-align:left">：</td>
<td style="text-align:left">表示命令引用结束之前</td>
</tr>
<tr>
<td style="text-align:left">；</td>
<td style="text-align:left">表示语句结束</td>
</tr>
<tr>
<td style="text-align:left">；；</td>
<td style="text-align:left">表示case语句的结束</td>
</tr>
<tr>
<td style="text-align:left">‘’</td>
<td style="text-align:left">表示字符串</td>
</tr>
<tr>
<td style="text-align:left">“”</td>
<td style="text-align:left">表示</td>
</tr>
<tr>
<td style="text-align:left">``</td>
<td style="text-align:left">表示命令的引用</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">表示覆盖</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">表示追加</td>
</tr>
<tr>
<td style="text-align:left">-&gt;</td>
<td style="text-align:left">表示链接指向</td>
</tr>
<tr>
<td style="text-align:left">？</td>
<td style="text-align:left">表示单个字符统配</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">表示赋值</td>
</tr>
<tr>
<td style="text-align:left">./</td>
<td style="text-align:left">表示执行</td>
</tr>
</tbody>
</table>
<p> linux中的比较预算符等同于批处理中的大于、小于、等于：gtr、lss、equ、neq、geq、leq</p>
<p>   #！表示的是bash脚本的开头<br>   |     管道<br>   ||       或  </p>
<hr>
<p>####shell脚本<br>    文本文档，针对linux中，单个命令无法进行完成，而是需要多个命令时，就可以将所有命令写到<br>    shell脚本中，直接运行shell脚本即可。主要采用的是C语言<br>   注意：Shell脚本—-必须具有可执行的权限，才能被执行 </p>
<p>####Shell脚本中相关解释<br>Echo ：输出命令（或者使用printf进行输出）<br>$?：表示验证脚本或者命令是否执行完成，如果结果是0表示执行成功，<br>如果是其他数字的话，则表示执行不成功。</p>
<pre><code>#！ /bin/bash  ---释伴行（声明为:是使用bash脚本的进行执行的）
{}枚举：如果{}中只有一个元素的话，则不会当成是元素，而是被看做一个整体，
只有存在多个元素的情况，才会被认定为枚举
举例 ：touch {a,b}-{c,d}   ----创建四个文件：a-c a-d  b-c  b-d
[表达式]：实现运算a=$[5+6];（如果a=5+6,会直接当成是字符串输出）
        或者：set a=expr 5+6
        或者：expr 8 + 9(注意空格)
        执行文件方式：./文件    或bash 文件
</code></pre><hr>
<p>###流程控制语句</p>
<p>If  [ 表达式 ] ；then<br>语句块<br>Elif [ 表达式 ] ；then<br>语句块<br>Else<br>语句块<br>Fi<br>Or<br>If  [ 表达式 ]<br>then<br>语句块<br>Else<br>语句块<br>Fi</p>
<p>Case 变量 in<br>标识符）<br>    语句块<br>;;</p>
<ul>
<li>)<br>  语句块<br>;;<br>Esac</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>! /bin/bash</div><div class="line">Echo “please input a number”</div><div class="line">Read x</div><div class="line">Echo “please input another number”</div><div class="line">Read y</div><div class="line">If [ $x –gt $y ] ; then</div><div class="line">Echo “x&gt;y”</div><div class="line">Elif  [ $x –eq $y ] ; then</div><div class="line">Echo “x==y”</div><div class="line">Else</div><div class="line">Echo “x&lt;y”</div><div class="line">fi</div><div class="line">实现从控制台输入数据：</div><div class="line"><span class="meta">#</span>！ /bin/bash</div><div class="line">Echo “please input str”</div><div class="line">Read x</div><div class="line">Case $x in</div><div class="line">	Root)</div><div class="line">	Echo “I am root”</div><div class="line">;;</div><div class="line">	*)</div><div class="line">	Echo ”nothing”</div><div class="line">;;</div><div class="line">Esac</div><div class="line"></div><div class="line">循环</div><div class="line">For i in `seq 1  10` ----表示按顺序</div><div class="line">Do</div><div class="line">Echo $i</div><div class="line">Done</div><div class="line">或者</div><div class="line">For((i=0;i&lt;=10;i++))</div><div class="line">&#123;</div><div class="line">Echo $i</div><div class="line">&#125;</div><div class="line"></div><div class="line">计算奇数偶数和</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Linux 学习（三）]]></title>
      <url>/2017/09/30/%E5%8E%9F-Linux-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h2><p>1.进程 </p>
<p>进程：可执行应用程序执行后产生的对应的进程，重量级；进程是由一个线程或多个线程构成；</p>
<p>线程：是计算机中的最小单位，轻量级（依赖和物理性是独立存在的）、损耗较低</p>
<p>假设进程1是由1、2线程组成；进程2是由2、3线程组成； </p>
<p>当进程1启动后，进程2则需等待进程1执行完毕，资源释放后，方可执行； </p>
<p>而当进程1如果一直都不释放资源，则容易造成死锁；</p>
<p>Zombie僵尸进程： </p>
<p>当存在很多僵尸进程说明什么问题：说明模块和模块之间的结构有问题（代码中只写了调用，没有写回收）；<br><a id="more"></a></p>
<p>Ps –ef—-查询静态进程监控 </p>
<p>Kill 进程号—-结束进程 </p>
<p>Kill -9 进程号—-强制结束进程 </p>
<p>Ps –ef|pgrep “httpd”—-查询httpd的端口号</p>
<hr>
<p>Top—查询（动态）进程 </p>
<p>{Load average：系统当前负载资源； </p>
<p>Tasks：进程数、zombie僵尸进程； </p>
<p>Id ：空闲的 </p>
<p>Mem：内存；buffer：缓存 </p>
<p>Swap：交换分区 </p>
<p>在top状态下，输入u：用户；显示指定的用户进程； </p>
<p>输入q：表示退出top状态；</p>
<hr>
<p>查询进程端口：netstat –ano  </p>
<p>Bash csh ksh tcsh </p>
<p>更改shell：chsh –s 目标</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">root目录或宿主目录</td>
</tr>
<tr>
<td style="text-align:left">！</td>
<td style="text-align:left">表示非</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:left">普通链接或者邮箱标识符</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">注释</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">变量</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取模</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">表示不在什么范围之中</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">表示与</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">表示统配</td>
</tr>
<tr>
<td style="text-align:left">（）</td>
<td style="text-align:left">表示函数</td>
</tr>
<tr>
<td style="text-align:left">-+*/</td>
<td style="text-align:left">表示运算符</td>
</tr>
<tr>
<td style="text-align:left">**</td>
<td style="text-align:left">表示幂运算</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">拖逸符</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">表示路径</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">表示枚举</td>
</tr>
<tr>
<td style="text-align:left">[表达式]</td>
<td style="text-align:left">表示的是条件逻辑判定</td>
</tr>
<tr>
<td style="text-align:left">：</td>
<td style="text-align:left">表示命令引用结束之前</td>
</tr>
<tr>
<td style="text-align:left">；</td>
<td style="text-align:left">表示语句结束</td>
</tr>
<tr>
<td style="text-align:left">；；</td>
<td style="text-align:left">表示case语句的结束</td>
</tr>
<tr>
<td style="text-align:left">‘’</td>
<td style="text-align:left">表示字符串</td>
</tr>
<tr>
<td style="text-align:left">“”</td>
<td style="text-align:left">表示</td>
</tr>
<tr>
<td style="text-align:left">``</td>
<td style="text-align:left">表示命令的引用</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">表示覆盖</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">表示追加</td>
</tr>
<tr>
<td style="text-align:left">-&gt;</td>
<td style="text-align:left">表示链接指向</td>
</tr>
<tr>
<td style="text-align:left">？</td>
<td style="text-align:left">表示单个字符统配</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">表示赋值</td>
</tr>
<tr>
<td style="text-align:left">./</td>
<td style="text-align:left">表示执行</td>
</tr>
</tbody>
</table>
<p>linux中的比较预算符等同于批处理中的大于、小于、等于：gtr、lss、equ、neq、geq、leq </p>
<p>   #！表示的是bash脚本的开头 </p>
<p>   |     管道 </p>
<p>   ||       或  </p>
<h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><pre><code>文本文档，针对linux中，单个命令无法进行完成，而是需要多个命令时，就可以将所有命令写到
shell脚本中，直接运行shell脚本即可。主要采用的是C语言


注意：Shell脚本—-必须具有可执行的权限，才能被执行 

#### Shell脚本中相关解释

Echo ：输出命令（或者使用printf进行输出） 

$?：表示验证脚本或者命令是否执行完成，如果结果是0表示执行成功， 

如果是其他数字的话，则表示执行不成功。

#！ /bin/bash  ---释伴行（声明为:是使用bash脚本的进行执行的）
{}枚举：如果{}中只有一个元素的话，则不会当成是元素，而是被看做一个整体，
只有存在多个元素的情况，才会被认定为枚举
举例 ：touch {a,b}-{c,d}   ----创建四个文件：a-c a-d  b-c  b-d
[表达式]：实现运算a=$[5+6];（如果a=5+6,会直接当成是字符串输出）
        或者：set a=expr 5+6
        或者：expr 8 + 9(注意空格)
        执行文件方式：./文件    或bash 文件
</code></pre><p>###流程控制语句</p>
<p>If  [ 表达式 ] ；then<br>语句块<br>Elif [ 表达式 ] ；then<br>语句块<br>Else<br>语句块<br>Fi<br>Or<br>If  [ 表达式 ]<br>then<br>语句块<br>Else<br>语句块<br>Fi</p>
<p>Case 变量 in<br>标识符）<br>    语句块<br>;;</p>
<ul>
<li>)<br>  语句块<br>;;<br>Esac</li>
</ul>
<p> #! /bin/bash<br>Echo “please input a number”<br>Read x<br>Echo “please input another number”<br>Read y<br>If [ $x –gt $y ] ; then<br>Echo “x&gt;y”<br>Elif  [ $x –eq $y ] ; then<br>Echo “x==y”<br>Else<br>Echo “x&lt;y”<br>fi</p>
<p>实现从控制台输入数据：</p>
<pre><code>#！ /bin/bash
</code></pre><p>Echo “please input str”<br>Read x<br>Case $x in<br>    Root)<br>    Echo “I am root”<br>;;<br>    *)<br>    Echo ”nothing”<br>;;<br>Esac</p>
<p>循环<br>For i in <code>seq 1  10</code> —-表示按顺序<br>Do<br>Echo $i<br>Done<br>或者<br>For((i=0;i&lt;=10;i++))<br>{<br>Echo $i<br>}</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Linux 学习（二）]]></title>
      <url>/2017/09/30/%E5%8E%9F-Linux-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h3><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">startx</td>
<td style="text-align:left">当前用户界面切换至图形界面</td>
</tr>
<tr>
<td style="text-align:left">init5</td>
<td style="text-align:left">切换至另一用户的图形化界面</td>
</tr>
<tr>
<td style="text-align:left">init3</td>
<td style="text-align:left">从图形界面切换回文本界面</td>
</tr>
<tr>
<td style="text-align:left">pwd</td>
<td style="text-align:left">显示当前用户路径</td>
</tr>
<tr>
<td style="text-align:left">logout</td>
<td style="text-align:left">注销</td>
</tr>
<tr>
<td style="text-align:left">shutdown/poweroff/halt</td>
<td style="text-align:left">关机</td>
</tr>
<tr>
<td style="text-align:left">reboot</td>
<td style="text-align:left">重启</td>
</tr>
<tr>
<td style="text-align:left">clear</td>
<td style="text-align:left">清屏</td>
</tr>
<tr>
<td style="text-align:left">who</td>
<td style="text-align:left">显示当前用户</td>
</tr>
<tr>
<td style="text-align:left">man</td>
<td style="text-align:left">找帮助</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="针对文件、文件夹的操作"><a href="#针对文件、文件夹的操作" class="headerlink" title="针对文件、文件夹的操作"></a>针对文件、文件夹的操作</h3><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rmdir</td>
<td style="text-align:left">删除文件夹（不能删除空文件夹）</td>
</tr>
<tr>
<td style="text-align:left">rmdir -rf</td>
<td style="text-align:left">递归删除非空目录下的一切（从里到外）</td>
</tr>
<tr>
<td style="text-align:left">rm</td>
<td style="text-align:left">删除文件</td>
</tr>
<tr>
<td style="text-align:left">rm -rf   *</td>
<td style="text-align:left">删除目录文件夹下所有</td>
</tr>
<tr>
<td style="text-align:left">Rm  -rf  相对路径</td>
<td style="text-align:left">删除相对路径下的文件夹或文件</td>
</tr>
<tr>
<td style="text-align:left">Rm  -rf 绝对路径</td>
<td style="text-align:left">删除绝对路径对应的文件夹或文件</td>
</tr>
<tr>
<td style="text-align:left">Touch 文件名</td>
<td style="text-align:left">创建空白文件</td>
</tr>
<tr>
<td style="text-align:left">cat   文件名</td>
<td style="text-align:left">查看 文件内容</td>
</tr>
<tr>
<td style="text-align:left">cp  文件   绝对路径</td>
<td style="text-align:left">拷贝文件至相应的位置</td>
</tr>
<tr>
<td style="text-align:left">mv  文件  绝对路径</td>
<td style="text-align:left">移动和剪切文件至指定位置</td>
</tr>
<tr>
<td style="text-align:left">which  命令</td>
<td style="text-align:left">查找命令的路径</td>
</tr>
<tr>
<td style="text-align:left">where is 命令</td>
<td style="text-align:left">查找命令配置的环境变量路径</td>
</tr>
<tr>
<td style="text-align:left">find  -文件名、文件夹名</td>
<td style="text-align:left">查找</td>
</tr>
<tr>
<td style="text-align:left">grep</td>
<td style="text-align:left">针对文件 查找行-按文件内容查找</td>
</tr>
<tr>
<td style="text-align:left">cut</td>
<td style="text-align:left">剪切文件字节数</td>
</tr>
</tbody>
</table>
<h3 id="文件的详细信息"><a href="#文件的详细信息" class="headerlink" title="文件的详细信息"></a>文件的详细信息</h3><blockquote>
<ul>
<li>Drwx——3 xiao big 4096 sep 14 08:12 test</li>
<li>D[rwx][—][—] 1+3+3+3</li>
<li>第一位：表示文件的类型；其中[D]文件夹（文件夹属于一个特殊的文件）</li>
</ul>
</blockquote>
<pre><code>[-]普通文件；
[l] 连接文件；
[c]字符设备文件；
[b]块设备文件block；
[p]管道文件；
</code></pre><blockquote>
<ul>
<li>第一个三位：所属主权限即拥有者</li>
<li>第二个三位：所属组权限（—表示没有任何权限）</li>
<li>第三个三位：不同组权限</li>
</ul>
</blockquote>
<pre><code>其中r[4]表示可读、w[2]表示可写、x[1]表示可执行 [-]表示无任何权限；
</code></pre><blockquote>
<ul>
<li>3：表示文件的连接数</li>
</ul>
</blockquote>
<pre><code>第一个xiaoi：文件[文件夹]的所属主（即拥有者）；
第二个big：文件[文件夹]的所属组
</code></pre><h3 id="用户的配置文件相关解释（-etc-passwd"><a href="#用户的配置文件相关解释（-etc-passwd" class="headerlink" title="用户的配置文件相关解释（/etc/passwd)"></a>用户的配置文件相关解释（/etc/passwd)</h3><blockquote>
<ul>
<li>Xiaobai :x:501:501::/home/xiaobai:/bin/bash<br>Xiaobai：用户名；      X：表示加密；      第一个501：表示用户id；</li>
<li>Colors:x:500:apple      colors：组名；      X：表示加密；<br>500：表示组id；      apple：该组关联的用户</li>
</ul>
</blockquote>
<h3 id="针对用户的操作"><a href="#针对用户的操作" class="headerlink" title="针对用户的操作"></a>针对用户的操作</h3><pre><code>|   命令  | 说明  |
</code></pre><p>| :—— |  :—–   |<br>|  useradd 用户名 |创建一个新的用户|<br>|  useradd -u 666 用户名  | 创建一个ID号为666的新用户          |<br>|  useradd -p 密码 用户名 | 创建用户，并一同创建密码         |<br>|  useradd -g 组名 用户名 | 创建用户并加入组（原组不存在，改加入新组） |<br>|  useradd -G 组名 用户名|创建用户并加入组（原组存在，并加入新组）      |<br>|          |<br>| Usermod -g 组号 用户名|  更改用户对应的主组   |<br>|  usermod -l 新名 旧名    |   给用户改名                 |<br>|  Usermod –L 用户名      |   锁住用户                     |<br>|   Usermod –U 用户名     |解锁用户|<br>|userdel 用户名             |删除用户，但不删除用户自家目录|<br>|userdel -rf 用户名         |删除用户，并删除用户自家目录 |</p>
<h3 id="用户组相关命令"><a href="#用户组相关命令" class="headerlink" title="用户组相关命令"></a>用户组相关命令</h3><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">groups 用户名</td>
<td style="text-align:left">查看用户所属组</td>
</tr>
<tr>
<td style="text-align:left">Groupadd 组名</td>
<td style="text-align:left">创建一个新的组</td>
</tr>
<tr>
<td style="text-align:left">groupdel组名</td>
<td style="text-align:left">删除组（该组是用户的主组的，则必须先删除用户对该组的关联）</td>
</tr>
<tr>
<td style="text-align:left">groupmod –n新用户名 老用户名</td>
<td style="text-align:left">为组改名</td>
</tr>
<tr>
<td style="text-align:left">groupmod –g 501 组名</td>
<td style="text-align:left">改变组GID</td>
</tr>
<tr>
<td style="text-align:left">gpasswd -d 用户名 组名</td>
<td style="text-align:left">把用户从组中删除</td>
</tr>
<tr>
<td style="text-align:left">gpasswd -a 用户名 组名</td>
<td style="text-align:left">增加用户到组</td>
</tr>
</tbody>
</table>
<hr>
<p> 用户组的概念：一组具有相同特征（权限）的用户的集合</p>
<h3 id="针对文件-文件夹-的权限设置"><a href="#针对文件-文件夹-的权限设置" class="headerlink" title="针对文件[文件夹]的权限设置"></a>针对文件[文件夹]的权限设置</h3><hr>
<table>
<thead>
<tr>
<th style="text-align:left">Chmod 715 文件[文件夹]名</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">7拥有者的权限4+2+1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1同组的权限1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">5不同组的权限4+1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">4[r]可读权限、2[w]可写权限、1[x]可执行权限</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">chmod u=r+w+x,g=r+x,o=r</th>
<th style="text-align:left">文件[文件夹]名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u拥有者；g所属组；o不同组；</td>
<td style="text-align:left">“+”：添加权限；“-”：撤销权限；</td>
</tr>
<tr>
<td style="text-align:left">1）同时给u\g\o赋权，用逗号隔开；</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2）如果一个文件夹能够可访问的话，；</td>
<td style="text-align:left">那么文件夹一定要具有可读可执行的权限</td>
</tr>
<tr>
<td style="text-align:left">3）每次添加的权限都会覆盖原有的权限；</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<hr>
<p>更改文件[文件夹]的所属主：chown  所属主  指定的文件</p>
<p>更改文件[文件夹]的所属组：Chgrp  所属组 文件</p>
<h3 id="Linux-中各种颜色代表含义（-etc-dir-colors）"><a href="#Linux-中各种颜色代表含义（-etc-dir-colors）" class="headerlink" title="Linux 中各种颜色代表含义（/etc/dir_colors）"></a>Linux 中各种颜色代表含义（/etc/dir_colors）</h3><ol>
<li>深蓝色   文件夹</li>
<li>绿色   可执行文件</li>
<li>白色    普通文件</li>
<li>靛蓝色    软链接文件</li>
<li>橙色    设备文件</li>
<li>红色     压缩文件</li>
<li>红底白字    无效文件</li>
<li>可自定义颜色</li>
</ol>
<hr>
<p>链接：硬链接和软链接 </p>
<p>硬链接hard link    ln 文件路径 目标文件路径 </p>
<p>软链接symbolic link    ln -s文件绝对路径 目标文件绝对路径 </p>
<p>两者区别<br>1）生成的硬链接是普通文件（白色），软链接是链接文件（靛蓝色）； </p>
<p>2）创建软链接时，源文件路径一定要为绝对路径； </p>
<p>3）如果源文件被删除，则软链接变成无效文件</p>
<hr>
<p>Wc 文件名  获取文件包含的行数、单词数、字节数 </p>
<p>Head    获取头部的相应数据； </p>
<p>Head 文件名默认获取文件的前10行内容； </p>
<p>Head –n 2 文件名：获取文件的前两行内容； </p>
<p>Head –c 2 文件名：获取文件的前两个字符； </p>
<p>Tail    获取尾部的相应数据； </p>
<p>Tail 文件名默认获取文件的后10行内容； </p>
<p>Cut –c 10 文件名   获取文件的每行的第10个字符；</p>
<hr>
<p>Linux中简单命令 </p>
<p>Date    获取当前系统时间 </p>
<p>Date –s“ 09/15/2015 12:30:00”：更改时间；注意 </p>
<p>Cal 年份  查看某年的日历 </p>
<p>Bc  进入计算状态； </p>
<p>Quit    退出计算状态；</p>
<hr>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>==重定向覆盖==（&gt;）表示对文件的覆盖：cat a.txt&gt;/root/ceshi.txt（将前面的结果覆盖目标文件） </p>
<p>==重定向追加==（&gt;&gt;）表示对文件的追加；（即：将前面的结果追加至目标文件中）</p>
<p>举例：截取源文件的第二行内容追加至另一个文件中： </p>
<p>head –n 2 a.txt|tail –n 1&gt;&gt;/home/b.txt</p>
<hr>
<h3 id="查看ip：ifconfig"><a href="#查看ip：ifconfig" class="headerlink" title="查看ip：ifconfig"></a>查看ip：ifconfig</h3><p>配置ip三种方式：</p>
<ol>
<li>临时ip：输入ifconfig  eth0 具体ip（举例：ifconfig eth0 192.168.5.2）</li>
<li>永久ip：输入setup回车；返回安装软件时的配置界面，选择network configuration，按提示完成ip设置；</li>
<li>永久ip：更改配置文件/etc/sysconfig/network-scripts/ifcfg-eth0：<br>BOOTPROTO=NONE/STATIC;<br>IPADDR=192.168.5.2<br>NETMASK=255.255.255.0<br>GATEWEY=192.168.5.1<br>注意：如果需要使用永久ip，必须重启网络服务；<br>service network restart（启动网卡）；<br>service network stop（禁用网卡，即停止网络服务）；<br>service network status（查看网络状态）；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（三）]]></title>
      <url>/2017/09/28/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>1.表：表示一个实体（客观存在的事物或抽象时间），可实现对实体的数据描述和数据操作。 </p>
<p>2.表结构：二位平面（行、列） </p>
<a id="more"></a>
<p>3.数据类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型名称</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整形</td>
<td style="text-align:left">bit(只存储0、1)   samllint    int      bigint     tinyint</td>
</tr>
<tr>
<td style="text-align:left">浮点型</td>
<td style="text-align:left">float  numeric(a,b)(a:整数位长度；b:小数位长度(四舍五入))</td>
</tr>
<tr>
<td style="text-align:left">字符型</td>
<td style="text-align:left">char(长度8000)    nchar(长度4000)</td>
</tr>
<tr>
<td style="text-align:left">字符串型</td>
<td style="text-align:left">varchar(长度8000)    nvarchar(长度4000)</td>
</tr>
<tr>
<td style="text-align:left">货币型</td>
<td style="text-align:left">money</td>
</tr>
<tr>
<td style="text-align:left">日期型</td>
<td style="text-align:left">datetime    samlldatetime</td>
</tr>
<tr>
<td style="text-align:left">文本型</td>
<td style="text-align:left">text ntext</td>
</tr>
<tr>
<td style="text-align:left">二进制型</td>
<td style="text-align:left">binary</td>
</tr>
<tr>
<td style="text-align:left">万能型</td>
<td style="text-align:left">sql variant</td>
</tr>
</tbody>
</table>
<p>4.表的语法 </p>
<p>Create table 表名 </p>
<p>( </p>
<p>列名 数据类型 </p>
<p>)</p>
<p>7.查询表记录 </p>
<p>Select * from 表名</p>
<p>8.插入一条记录 </p>
<p>Insert into 表名（列名） </p>
<p>Values (内容)</p>
<p>9.增加列名 </p>
<p>Alter table 表名 </p>
<p>Add 列名 数据类型</p>
<ol>
<li><p>修改列名<br>Alter table 表名<br>Alter column 列名 数据类型</p>
</li>
<li><p>删除列名<br>Alter table 表名<br>Drop column 列名</p>
</li>
<li><p>查询表结构<br>Exec sp_help 表名<br>Exec sp_column s 表名</p>
</li>
<li><p>删除表<br>Drop table 表名</p>
</li>
<li><p>重命名表<br>Exec sp_rename ‘旧表名’,‘新表名’</p>
</li>
<li><p>重命名列<br>Exec sp_rename ‘表名.旧列名’,‘新列名’</p>
</li>
<li><p>删除记录<br>（1）删除所有记录：<br>Delete from 表名<br>（2）删除特定记录：<br>Delete from 表名 where 条件</p>
</li>
<li><p>修改记录<br>Update 表名<br>Set （修改内容）<br>Where （条件）</p>
</li>
</ol>
<p>–创建表<br>create table class_A(<br>id int primary key not null,<br>name varchar(10),<br>sex varchar(10),<br>coursr varchar(10),<br>score float<br>)</p>
<p>–查询表<br>select * from class_A</p>
<p>–插入数据<br>insert into class_A values(001,’李明’,’male’,’Java’,80)</p>
<p>–插入多条数据<br>insert into class_A values(002,’慕容雪’,’female’,’python’,65.5),<br>(003,’少白’,’male’,’Linux’,100),(004,’慕尼黑’,’male’,’oracle’,77)</p>
<p>–新增列<br>alter table class_A<br>add sex char(5)</p>
<p>–修改列名<br>alter table class_A<br>alter column sex varchar(20)</p>
<p>–删除列<br>alter table class_A<br>drop column sex</p>
<p>–查询表结构<br>exec sp_help class_A<br>exec sp_columns class_A</p>
<p>–删除表<br>drop table class_A</p>
<p>–重命名表名<br>exec sp_rename class_A,学生表</p>
<p>–重命名列名<br>exec sp_rename ‘class_A.name’,’姓名’</p>
<p>–修改记录<br>update class_A set class_A.sex=’female’where id=2</p>
<p>–删除记录<br>delete from class_A</p>
<p>–删除特定记录<br>delete from  class_A where ID=1</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[转]软件测试概念]]></title>
      <url>/2017/09/27/%E8%BD%AC-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h2 id="软件测试概念"><a href="#软件测试概念" class="headerlink" title="软件测试概念"></a>软件测试概念</h2><h4 id="1-软件测试概念"><a href="#1-软件测试概念" class="headerlink" title="1.软件测试概念"></a>1.软件测试概念</h4><pre><code>    广义概念：指软件生存周期中所有的检查、评审和确认工作，其中包括了对分析、设计阶段，
以及完成开发后维护阶段的各类文档、代码的审查和确认
    狭义概念：识别软件缺陷的过程，即实际结果与预期结果的不一致
</code></pre><h4 id="2-软件测试目的"><a href="#2-软件测试目的" class="headerlink" title="2.软件测试目的"></a>2.软件测试目的</h4><pre><code>测试的目的就是发现软件中的各种缺陷
测试只能证明软件存在缺陷，不能证明软件不存在缺陷
测试可以使软件中缺陷降低到一定程度，而不是彻底消灭
以较少的用例、时间和人力找出软件中的各种错误和缺陷，以确保软件的质量
</code></pre><a id="more"></a>
<h4 id="3．软件测试原则"><a href="#3．软件测试原则" class="headerlink" title="3．软件测试原则"></a>3．软件测试原则</h4><ol>
<li>Good-enough: 一种权衡投入/产出比的原则</li>
<li>保证测试的覆盖程度，但穷举测试是不可能的</li>
<li>所有的测试都应追溯到用户需求</li>
<li>越早测试越好，测试过程与开发过程应是相结合的</li>
<li>测试的规模由小而大，从单元测试到系统测试</li>
<li>为了尽可能地发现错误，应该由独立的第三方来测试</li>
<li>不能为了便于测试擅自修改程序</li>
<li><p>既应该测试软件该做什么也应该测试软件不该做什么</p>
<h4 id="4．软件测试的的重点"><a href="#4．软件测试的的重点" class="headerlink" title="4．软件测试的的重点"></a>4．软件测试的的重点</h4><p>1)测试用例的设计<br>   测试用例的设计是整个软件测试工作的核心<br>   测试用例反映对被测对象的质量要求，决定对测试对象的质量评估<br>2)测试工作的管理<br>   尤其是对包含多个子系统的大型软件系统，其测试工作涉及大量人力和物力，有效的测试工作管理是保证有效测试工作的必要前提<br>3）测试环境的建立</p>
</li>
</ol>
<h4 id="5．黑盒测试"><a href="#5．黑盒测试" class="headerlink" title="5．黑盒测试"></a>5．黑盒测试</h4><h5 id="什么是黑盒测试？"><a href="#什么是黑盒测试？" class="headerlink" title="什么是黑盒测试？"></a>什么是黑盒测试？</h5><pre><code>  又称功能测试或数据驱动测试，是针对软件的功能需求/实现进行测试，通过测试来检测每个功能
是否符合需求，不考虑程序内部的逻辑结构
</code></pre><h5 id="黑盒测试方法"><a href="#黑盒测试方法" class="headerlink" title="黑盒测试方法"></a>黑盒测试方法</h5><ol>
<li>功能划分</li>
<li>等价类划分</li>
<li>边界值分析</li>
<li>因果图</li>
<li>错误推测……<br>(详见博文用例设计<a href="http://blog.csdn.net/qq_36155340/article/details/73800006" target="_blank" rel="external">黑河测试八大法</a>)</li>
</ol>
<h4 id="6．什么是白盒测试"><a href="#6．什么是白盒测试" class="headerlink" title="6．什么是白盒测试"></a>6．什么是白盒测试</h4><pre><code>   白盒测试也称结构测试或逻辑驱动测试，必须知道软件内部工作过程，
通过测试来检测软件内部是否按照需求、设计正常运行
</code></pre><h5 id="白盒测试的主要方法"><a href="#白盒测试的主要方法" class="headerlink" title="白盒测试的主要方法"></a>白盒测试的主要方法</h5><pre><code>对应于程序的一些主要结构：语句、分支、逻辑路径、变量；白盒测试的主要方法是：
语句覆盖方法
分支覆盖方法
逻辑覆盖方法.....
(白盒测试六大法----暂未发布博文------)
</code></pre><h4 id="7-什么是动态测试"><a href="#7-什么是动态测试" class="headerlink" title="7.什么是动态测试"></a>7.什么是动态测试</h4><pre><code>动态测试需要在开发/测试环境或实际运行环境中运行软件，并使用测试用例去查找软件缺陷；
动态测试包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等  
</code></pre><h4 id="8-什么是静态测试"><a href="#8-什么是静态测试" class="headerlink" title="8.什么是静态测试"></a>8.什么是静态测试</h4><pre><code>它可以由人工进行，也可以借助软件工具自动进行 
</code></pre><h4 id="9-手工测试和自动测试"><a href="#9-手工测试和自动测试" class="headerlink" title="9.手工测试和自动测试"></a>9.手工测试和自动测试</h4><pre><code>a.手工测试缺点在于测试工作量大，重复多，回归测试难以实现
b.自动测试利用软件测试工具自动实现全部或部分测试工作：管理、设计、执行和报告；节省大量
的测试开销，并能够完成一些手工测试无法实现的测试
</code></pre><h4 id="手工完成测试的全部过程无法保证测试的科学性与严密性"><a href="#手工完成测试的全部过程无法保证测试的科学性与严密性" class="headerlink" title="手工完成测试的全部过程无法保证测试的科学性与严密性:"></a>手工完成测试的全部过程无法保证测试的科学性与严密性:</h4><pre><code>修改的缺陷越多，回归测试越困难
没有人能向决策层提供精确的数据以度量当前的工作进度及工作效率
反复测试带来的倦怠情绪及其他人为因素使得测试标准前后不一
测试花费的时间越长，测试的严格性也就越低
</code></pre><h4 id="自动测试将测试人员从反复、烦杂的测试执行中解放出来，用更多的时间进行测试设计和结果分析"><a href="#自动测试将测试人员从反复、烦杂的测试执行中解放出来，用更多的时间进行测试设计和结果分析" class="headerlink" title="自动测试将测试人员从反复、烦杂的测试执行中解放出来，用更多的时间进行测试设计和结果分析"></a>自动测试将测试人员从反复、烦杂的测试执行中解放出来，用更多的时间进行测试设计和结果分析</h4><pre><code>软件测试不可能完全自动化 

不能完成所有手工测试任务 

无创造性且灵活性差，不能改进测试的有效性 

过程中可能会遇到许多意想不到的问题，特别是当软件不稳定时 

测试脚本的维护高
</code></pre><hr>
<h4 id="10-测试流程"><a href="#10-测试流程" class="headerlink" title="10. 测试流程"></a>10. 测试流程</h4><pre><code>单元测试  

集成测试  

系统测试  

用户验收测试  

回归测试 
</code></pre><p><img src="http://img.blog.csdn.net/20170927173438809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></p>
<p><img src="http://img.blog.csdn.net/20170927173540017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="2"></p>
<hr>
<h4 id="11-单元测试"><a href="#11-单元测试" class="headerlink" title="11.单元测试"></a>11.单元测试</h4><pre><code>完成对最小的软件设计单元—模块的验证工作 

目标是确保模块被正确地编码 

使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误 

通常情况下是面向白盒的 

对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早地发现和解决不易显现的错误 

单元测试的内容 

–接口测试 

–内部数据结构 

–全局数据结构 

–边界 

–语句覆盖，错误路径
</code></pre><h4 id="12-集成测试"><a href="#12-集成测试" class="headerlink" title="12.集成测试"></a>12.集成测试</h4><pre><code>通过测试发现与模块接口有关的问题 

目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构  

应当避免一次性的集成（除非软件规模很小），而采用增量集成 

集成测试主要内容 

API 

API/参数组合
</code></pre><h4 id="13．系统测试"><a href="#13．系统测试" class="headerlink" title="13．系统测试"></a>13．系统测试</h4><pre><code>根据软件需求规范的要求进行系统测试，确认系统满足需求的要求 

系统测试人员相当于用户代言人 

在需求分析阶段要确定软件的可测性，保证有效完成系统测试工作 

系统测试主要内容 

所有功能需求得到满足 

所有性能需求得到满足 

其他需求（例如安全性、容错性、兼容性等）得到满足
</code></pre><h4 id="14-用户验收-确认测试"><a href="#14-用户验收-确认测试" class="headerlink" title="14.用户验收/确认测试"></a>14.用户验收/确认测试</h4><pre><code>Alpha测试 

–是由用户在开发者的场所来进行的，Alpha测试是在一个受控的环境中进行的 

Beta测试 

–由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，
用户记录测试中遇到的问题并报告给开发者
</code></pre><h4 id="15．压力测试VS性能测试"><a href="#15．压力测试VS性能测试" class="headerlink" title="15．压力测试VS性能测试"></a>15．压力测试VS性能测试</h4><pre><code>   性能测试的目的不是去找bugs,而是排除系统的瓶颈，以及为以后的回归测试建立一个基准。
   而性能测试的操作，实际上就是一个非常小心受控的测量分析过程。在理想的情况下，
被测软件在这个时候已经是足够稳定了
每个用户是否都还可以正常的完成操作等。
   概括就是：在不同负载下（负载一定）时，通过一些系统参数（如反应时间等）检查系统的运行情况；
   压力测试是为了发现系统能支持的最大负载，他的前提是要求系统性能处在可以接受的范围内，
比如经常规定的叶面3秒钟内响应；
   概括就是：在性能可以接受的前提下，测试系统可以支持的最大负载。
如果同时对系统进行大量的数据查询操作，就包含了强度测试。
</code></pre><hr>
<h3 id="软件生命周期-SDLC-的六个阶段"><a href="#软件生命周期-SDLC-的六个阶段" class="headerlink" title="软件生命周期(SDLC)的六个阶段"></a>软件生命周期(SDLC)的六个阶段</h3><h4 id="1、问题的定义及规划"><a href="#1、问题的定义及规划" class="headerlink" title="1、问题的定义及规划"></a>1、问题的定义及规划</h4><pre><code>此阶段是软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。
</code></pre><h4 id="2、需求分析"><a href="#2、需求分析" class="headerlink" title="2、需求分析"></a>2、需求分析</h4><pre><code>   在确定软件开发可行的情况下，对软件需要实现的各个功能进行详细分析。
需求分析阶段是一个很重要的阶段，这一阶段做得好，将为整个软件开发项目的成功打下良好的
基础。&quot;唯一不变的是变
化本身。&quot;，同样需求也是在整个软件开发过程中不断变化和深入的，因此我们必须制定需求变更计
划来应付这种变化，以保护整个项目的顺利进行。
</code></pre><h4 id="3、软件设计"><a href="#3、软件设计" class="headerlink" title="3、软件设计"></a>3、软件设计</h4><pre><code> 此阶段主要根据需求分析的结果，对整个软件系统进行设计，如系统框架设计，数据库设计等等。
软件设计一般分为总体设计和详细设计。好的软件设计将为软件程序编写打下良好的基础。
</code></pre><h4 id="4、程序编码"><a href="#4、程序编码" class="headerlink" title="4、程序编码"></a>4、程序编码</h4><pre><code>    此阶段是将软件设计的结果转换成计算机可运行的程序代码。在程序编码中必须要制定统一，
符合标准的编写规范。以保证程序的可读性，易维护性，提高程序的运行效率。
</code></pre><h4 id="5、软件测试"><a href="#5、软件测试" class="headerlink" title="5、软件测试"></a>5、软件测试</h4><pre><code>  在软件设计完成后要经过严密的测试，以发现软件在整个设计过程中存在的问题并加以纠正。
整个测试过程分单元测试、组装测试以及系统测试三个阶段进行。测试的方法主要有白盒测试和黑
盒测试两种。在测试过程中需要建立详细的测试计划并严格按照测试计划进行测试，以减少测试的
随意性。
</code></pre><h4 id="6、运行维护"><a href="#6、运行维护" class="headerlink" title="6、运行维护"></a>6、运行维护</h4><pre><code>软件维护是软件生命周期中持续时间最长的阶段。在软件开发完成并投入使用后，由于多方面的原
因，软件不能继续适应用户的要求。要延续软件的使用寿命，就必须对软件进行维护。软件的维护
包括纠错性维护和改进性维护两个方面。

从概念提出的那一刻开始，软件产品就进入了软件生命周期。在经历需求、分析、设计、实现、部
署后，软件将被使用并进入维护阶段，直到最后由于缺少维护费用而逐渐消亡。这样的一个过程，
称为&quot;生命周期模型&quot;（Life Cycle Model）
</code></pre><h3 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h3><p>瀑布模型的特点（文档是主体），很多的问题在最后才会暴露出来。 </p>
<p>迭代模型比瀑布模型问题暴露的要早； </p>
<p>快速原型法比瀑布模型直观。</p>
<p>=============================</p>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><h3 id="主流测试工具的测试流程"><a href="#主流测试工具的测试流程" class="headerlink" title="主流测试工具的测试流程"></a>主流测试工具的测试流程</h3><h3 id="winrunner"><a href="#winrunner" class="headerlink" title="winrunner"></a>winrunner</h3><p>1　启动时选择要加载的插件 </p>
<p>2　进行一些设置（如录制模式等） </p>
<p>3　识别应用程序的GUI，即创建map(就是学习被测试软件的界面） </p>
<p>4　建立测试脚本（录制及编写） </p>
<p>5　对脚本除错及调试（保证能够运行完） </p>
<p>6　插入各种检查点（图片，文字，控件等） </p>
<p>7　在新版应用程序中执行测试脚本 </p>
<p>8　分析结果，回报缺陷 </p>
<h3 id="quicktestpro"><a href="#quicktestpro" class="headerlink" title="quicktestpro"></a>quicktestpro</h3><p>1　准备录制 </p>
<p>打开你要对其进行测试的应用程序，并检查QuickTest中的各项设置是否适合当前的要求。</p>
<p>2　进行录制 </p>
<p>打开QuickTest的录制功能，按测试用例中的描述，操作被测试应用程序。</p>
<p>3　编辑测试脚本 </p>
<p>通过加入检测点、参数化测试，以及添加分支、循环等控制语句，来增强测试脚本的功能，使将来的回归测试真正能够自动化。</p>
<p>4　调试脚本 </p>
<p>调试脚本，检查脚本是否存在错误。</p>
<p>5　在回归测试中运行测试 </p>
<p>在对应用程序的回归测试中，通过QuickTest回放对应用程序的操作，检验软件正确性，实现测试的自动化进行。</p>
<p>6　分析结果，报告问题 </p>
<p>查看QuickTest记录的运行结果，记录问题，报告测试结果。</p>
<h3 id="TestDirect"><a href="#TestDirect" class="headerlink" title="TestDirect"></a>TestDirect</h3><p>安装好后，先进入站点管理 </p>
<p>1　创建域及工程 </p>
<p>2　添加用户 </p>
<p>3　编辑licenses及本服务器 </p>
<p>4　编辑数据库</p>
<h3 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h3><p>1　选择新建的工程进行定制(列表，用户，组，版本等) </p>
<p>2　在require中增加需求 </p>
<p>3　把需求转化为plan </p>
<p>4 在testlab中由计划新建测试具体用例与执行 </p>
<p>5　发现bug，在defect中提交bug </p>
<p>（每一部分都可以相对独立地使用）</p>
<h3 id="loadrunner"><a href="#loadrunner" class="headerlink" title="loadrunner"></a>loadrunner</h3><p>1　制定负载测试计划 </p>
<p>(分析应用程序， 确定测试目标，计划怎样执行LoadRunner）</p>
<p>2　开发测试脚本 </p>
<p>（录制基本的用户脚本，完善测试脚本）</p>
<p>3　创建运行场景 </p>
<p>（选择场景类型为Manual Scenario，选择场景类型，理解各种类型，场景的类型转化）</p>
<p>4　运行测试</p>
<p>5　监视场景 </p>
<p>（MEMORY 相关，PROCESSOR相关，网络吞量以及带宽，磁盘相关，WEB应用程序 ，IIS5.0，SQL SERVER，NETWORK DELAY等)</p>
<p>6　分析测试结果 </p>
<p>(分析实时监视图表,分析事务的响应时间,分解页面,确定WEBSERVER的问题,其他有用的功能)</p>
<p>=========此文未转载自微信公众号+个人修改=========</p>
]]></content>
      
        <categories>
            
            <category> 测试经验文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]接口测试（一）--soapui实践]]></title>
      <url>/2017/09/27/%E5%8E%9F-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89-soapui%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h3 id="一、接口的概念"><a href="#一、接口的概念" class="headerlink" title="一、接口的概念"></a>一、接口的概念</h3><pre><code>  接口是指系统模块与模块或系统与系统之间进行交互，一般用的多的是HTTP协议的接口、
webService协议的接口，还有RPC的接口。
RPC:Remote Procedure Call Protocol 远程过程调用协议
  本质是客户端发送一个请求（Request），服务器响应后返回一个Response，然后我们对
Response进行分析，这就是接口测试。
</code></pre><a id="more"></a>
<h3 id="二、接口测试的目的"><a href="#二、接口测试的目的" class="headerlink" title="二、接口测试的目的"></a>二、接口测试的目的</h3><p>核心：保证系统稳定 </p>
<p>   方式：持续集成 </p>
<p>   目的：提高测试效率，保证数据的准确性 </p>
<p>   文档：接口的数据类型是需要事先定义好的，所以要形成文档，方便查阅，尽量减少团队与团队之间的沟通成本；同理，我们测试也要根据文档整理出接口测试的数据，整理出断言字段，也方便别人去审核我们接口测试的成果。</p>
<h3 id="三、Soapui-测试WebService接口"><a href="#三、Soapui-测试WebService接口" class="headerlink" title="三、Soapui 测试WebService接口"></a>三、Soapui 测试WebService接口</h3><p>1)构建项目； </p>
<p>2)运行单个请求； </p>
<p>3)构建测试用例； </p>
<p>4)接口之间传递参数，组织测试步骤； </p>
<p>5)运行整个测试用例。 </p>
<p>接口实例： </p>
<p>国内飞机航班时刻表 WEB 服务  </p>
<p>Endpoint:<a href="http://www.webxml.com.cn/webservices/DomesticAirline.asmx" target="_blank" rel="external"> 国内飞机航班时刻表有关定义</a> </p>
<p>Disco:<a href="http://www.webxml.com.cn/webservices/DomesticAirline.asmx?disco" target="_blank" rel="external">链接</a> </p>
<p>WSDL:<a href="http://www.webxml.com.cn/webservices/DomesticAirline.asmx?wsdl" target="_blank" rel="external">soap接口地址</a></p>
<h4 id="1-新建项目，输入WSDL"><a href="#1-新建项目，输入WSDL" class="headerlink" title="1.新建项目，输入ＷＳＤＬ"></a>1.新建项目，输入ＷＳＤＬ</h4><p><img src="http://img.blog.csdn.net/20170927162415220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图1"></p>
<p><img src="http://img.blog.csdn.net/20170927162457876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图2"></p>
<h4 id="2-根据soap的版本不同提供了两种不同接口。接口请求中的“？”表示要入参"><a href="#2-根据soap的版本不同提供了两种不同接口。接口请求中的“？”表示要入参" class="headerlink" title="2.根据soap的版本不同提供了两种不同接口。接口请求中的“？”表示要入参"></a>2.根据soap的版本不同提供了两种不同接口。接口请求中的“？”表示要入参</h4><p>getDomesticAirlinesTime ：获取航班时间 </p>
<p>getDomesticCity ：获取航班城市</p>
<p><img src="http://img.blog.csdn.net/20170927162641704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图3"></p>
<h4 id="3-运行单个请求"><a href="#3-运行单个请求" class="headerlink" title="3.运行单个请求"></a>3.运行单个请求</h4><p><img src="http://img.blog.csdn.net/20170927162729913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图4"></p>
<h4 id="4-点击Request，输入参数，点击绿色按钮运行"><a href="#4-点击Request，输入参数，点击绿色按钮运行" class="headerlink" title="4.点击Request，输入参数，点击绿色按钮运行"></a>4.点击Request，输入参数，点击绿色按钮运行</h4><p><img src="http://img.blog.csdn.net/20170927162813625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图5"></p>
<h4 id="5-构建测试用例"><a href="#5-构建测试用例" class="headerlink" title="5.构建测试用例"></a>5.构建测试用例</h4><p>右键点击项目，创建MyTestSuite</p>
<p><img src="http://img.blog.csdn.net/20170927162925953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图6"> </p>
<p>右键点击MyTestSuite，创建MyTestCase</p>
<p><img src="http://img.blog.csdn.net/20170927163013376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图7"></p>
<p>新建的TestCase包括三个部分，现只需关注功能部分。 </p>
<pre><code>![图9](http://img.blog.csdn.net/20170927163222930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
</code></pre><p>添加请求到TestCase </p>
<p><img src="http://img.blog.csdn.net/20170927163543059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图10"></p>
<p>添加后，即拥有了第一个测试用例，只需点击绿色按钮运行用例。</p>
<p><img src="http://img.blog.csdn.net/20170927163622872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图11"></p>
<h3 id="6-增加检查点"><a href="#6-增加检查点" class="headerlink" title="6.增加检查点"></a>6.增加检查点</h3><p><img src="http://img.blog.csdn.net/20170927163707575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图12"> </p>
<p>有7种断言类型可以选择（Recently used为你最近使用过的断言）。这里我们选择“Property Content”下的Contains，这是根据返回的属性内容设置检查点。</p>
<p><img src="http://img.blog.csdn.net/20170927163759035?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图13"> </p>
<p>输入检查内容，点击OK</p>
<p><img src="http://img.blog.csdn.net/20170927163813342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图14"></p>
<p>然后运行服务请求，如下图所示，在“Assertions”窗口中可以看到“myAssertion - VALID”说明检查点是有效的。 </p>
<p><img src="http://img.blog.csdn.net/20170927163909918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图15"></p>
<h3 id="7-传递参数，接口之间组织测试步骤。将getDomesticCity获取航班城市编号传入getDomesticAirlinesTime-。"><a href="#7-传递参数，接口之间组织测试步骤。将getDomesticCity获取航班城市编号传入getDomesticAirlinesTime-。" class="headerlink" title="7.传递参数，接口之间组织测试步骤。将getDomesticCity获取航班城市编号传入getDomesticAirlinesTime 。"></a>7.传递参数，接口之间组织测试步骤。将getDomesticCity获取航班城市编号传入getDomesticAirlinesTime 。</h3><p><img src="http://img.blog.csdn.net/20170927163923969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图16"></p>
<p>点击 新建Transfer，命名为City1、City2。设置sourcet和Target</p>
<p><img src="http://img.blog.csdn.net/20170927164041990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="17"></p>
<p><img src="http://img.blog.csdn.net/20170927164124946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="18"></p>
<p><img src="http://img.blog.csdn.net/20170927164135794?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="19"></p>
<p><img src="http://img.blog.csdn.net/20170927164146572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="20"></p>
<p>整个测试步骤设置好之后，打开“myTestCase”运行测试，全部绿色表示测试通过：</p>
<p><img src="http://img.blog.csdn.net/20170927164229954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="21"></p>
<p>查看log</p>
<p><img src="http://img.blog.csdn.net/20170927164244927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="22"></p>
]]></content>
      
        <categories>
            
            <category> 接口测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 接口测试 </tag>
            
            <tag> SoapUI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Monkey测试总结]]></title>
      <url>/2017/09/27/%E5%8E%9F-Monkey%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>##Monkey测试总结</p>
<p>###1.什么是Monkey<br>       Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪<br>    随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，<br>       实现对正在开发的应用程序进行压力测试。<br>    Monkey测试是一种为了测试软件稳定性、健壮性的快速有效的方法。<br>    Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是：/<br>    system/framework/monkey.jar。Monkey.<br>       jar程序是由一个名为“monkey”的shell脚本来启动执行，shell脚本在Android文件系统中的<br>    存放路是：/system/bin/monkey；<br>       这样就可以通过在CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测了。<br>     打开CMD窗口，输入adb shell ls /system/framework，可以查看到monkey.jar；同理，可查看monkey。</p>
<a id="more"></a>
<p>###2.Monkey测试的特点</p>
<blockquote>
<ul>
<li>测试的对象仅为应用程序包，有一定的局限性。</li>
<li>Monkey测试使用的事件流数据流是随机的，不能进行自定义。</li>
<li>可对MonkeyTest的对象，事件数量，类型，频率等进行设置。</li>
</ul>
</blockquote>
<p>###3.Monkey的基本用法<br>    1）Monkey测试准备<br>       在执行Monkey测试之前，我们需要下载ADB工具，并安装JDK v1.5以上的版本。<br>    ADB工具是谷歌提供的Android调试工具，可以通过linux命令行访问手机。<br>       安装好JDK环境，下载adbtools之后，我们需要配置一下环境变量，<br>    把adbtools的存放路径添加到path中，我们可以开始进行Monkey测试。<br>    注：需要root权限。<br>    2）基本语法如下：<br>    $ adb devices<br>       这个命令是查看当前连接的设备,?连接到计算机的android设备或者模拟器将会列出显示。<br>    $adb install<br>    adb install <apk文件路径> ：这个命令将指定的apk文件安装到设备上<br>    adb install??-r <apk文件路径> ：如果加-r参数会覆盖原来安装的软件并保留数据<br>    注意：apk文件名不要使用中文且不要有空格号<br>    $ adb shell monkey [options]<br>    它启动指定的应用程序，并向其发送500 个伪随机事件：<br>    $ adb shell monkey -p your.package.name -v 500</apk文件路径></apk文件路径></p>
<p>###4.monkey测试的相关的原理<br>      monkey测试的原理就是利用socket通讯的方式来模拟用户的按键输入，触摸屏输入，手势输入<br>    等，看设备多长时间会出异常。<br>      当Monkey程序在模拟器或设备运行的时候，如果用户触发了比如点击，触摸，<br>    手势或一些系统级别的事件的时候，<br>    它就会产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件。</p>
<p>###5.monkey实例<br>    1）启动Android模拟器<br>    2）在命令行中输入：adb devices查看设备连接情况</p>
<pre><code>3）在有设备连接的前提下，在命令行中输入：adb shell?进入shell界面

4）查看data/data文件夹下的应用程序包。注：我们能测试的应用程序包都在这个目录下面

5）以com.tencent.mobileqq为对象，进行monkey test
</code></pre><p><code>monkey -p com.tencent.mobileqq -v 500</code></p>
<pre><code>6）另一种执行方法
</code></pre><p><code>adb shell monkey -p com.tencent.mobileqq -v 500&gt;E:\monkey\test.log</code></p>
<p>###6.Monkey测试的停止条件<br>    Monkey Test执行过程中在下列三种情况下会自动停止：<br>    1）如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。<br>    2）如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错<br>    3）如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。<br>    通过多次并且不同设定下的Monkey测试才算它是一个稳定性足够的程序。</p>
<pre><code>工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。monkey 测试命令如下：
</code></pre><p>adb shell monkey -p com.xy.android.junit -s 500 –ignore-crashes<br>–ignore-timeouts –monitor-native-crashes -v -v 10000 &gt; E:\monkey\log.txt</p>
<pre><code>  Monkey测试是Android自动化测试里面使用比较简单的方法，可以很大程度检验我们的程序是否
稳定，能否经得起压力测试，
可以根据实际情况调整测试的强度和测试重点。

Monkey测试只是一个模拟测试，很多时候跟实际情况时有差别的，所以这个只能是其中一个辅助测试。
</code></pre><p>##基本命令</p>
<p>###一、Monkey测试简介<br>    Monkey测试是Android平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动<br>    Trackball、按键等操作来对设备上的程序进行压力测试，<br>    检测程序多久的时间会发生异常。</p>
<p>###二、Monkey程序介绍<br>    1) Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径<br>    是：/system/framework/monkey.jar；<br>    2) Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件<br>    系统中的存放路径是：/system/bin/monkey；<br>    这样就可以通过在CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试了。</p>
<p>###三、Monkey命令的简单帮助<br>    要获取Monkey命令自带的简单帮助，在CMD中执行命令：<br>    adb shell monkey –help</p>
<p>###四、Monkey命令参数介绍<br>    1) 参数：-p<br>    参数-p用于约束限制，用此参数指定一个或多个包（Package，即App）。指定包之后，Monkey将<br>    只允许系统启动指定的APP。<br>    如果不指定包，Monkey将允许系统启动设备中的所有APP。</p>
<pre><code>* 指定一个包： adb shell monkey -p com.htc.Weather??100
说明：com.htc.Weather为包名，100是事件计数（即让Monkey程序模拟100次随机用户事件）。
* 指定多个包：
adb shell monkey -p com.htc.Weather –p com.htc.pdfreader -p com.htc.photo.widgets 100
* 不指定包：adb shell monkey 100说明：
* Monkey随机启动APP并发送100个随机事件。
* 要查看设备中所有的包，在CMD窗口中执行以下命令：
</code></pre><blockquote>
<p> adb shell<br> cd data/data<br> ls</p>
</blockquote>
<pre><code>2) 参数: -v
用于指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下表所示：
</code></pre><blockquote>
<ul>
<li><p>日志级别 Level 0</p>
<p> 示例 adb shell monkey -p com.htc.Weather –v 100<br>说明 缺省值，仅提供启动提示、测试完成和最终结果等少量信息</p>
</li>
<li><p>日志级别 Level 1</p>
<p> 示例 adb shell monkey -p com.htc.Weather –v -v 100<br>说明??提供较为详细的日志，包括每个发送到Activity的事件信息?</p>
</li>
<li><p>日志级别 Level 2<br>示例 adb shell monkey -p com.htc.Weather –v -v –v 100<br>说明??最详细的日志，包括了测试中选中/未选中的Activity信息</p>
</li>
<li><p>3)参数：-s<br>用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。</p>
</li>
<li><p>示例：<br>　Monkey测试1：adb shell monkey -p com.htc.Weather –s 10 100<br> Monkey 测试2：adb shell monkey -p com.htc.Weather –s 10 100<br> 两次测试的效果是相同的，因为模拟的用户操作序列（每次操作按照一定的先后顺序所组成的一系列操作，即一个序列）是一样的。操作序列虽? ?然是随机生成的，但是只要我们指定了相同的Seed值，就可以保证两次测试产生的随机操作序列是完全相同的，所以这个操作序列伪随机的；</p>
</li>
<li><p>4) 参数：–throttle &lt;毫秒&gt;<br>用于指定用户操作（即事件）间的时延，单位是毫秒；</p>
</li>
<li><p>示例：adb shell monkey -p com.htc.Weather –throttle 3000 100</p>
</li>
<li><p>5) 参数：–ignore-crashes<br>用于指定当应用程序崩溃时（Force &amp; Close错误），Monkey是否停止运行。如果使用此参数，即使应用程序崩溃，Monkey依然会发送事件，直到事件计数完成。</p>
</li>
<li>示例1：adb shell monkey -p com.htc.Weather –ignore-crashes 1000<br>测试过程中即使Weather程序崩溃，Monkey依然会继续发送事件直到事件数目达到1000为止；</li>
<li>示例2：adb shell monkey -p com.htc.Weather 1000<br>测试过程中，如果Weather程序崩溃，Monkey将会停止运行。</li>
</ul>
<ul>
<li><p>6) 参数：–ignore-timeouts<br>用于指定当应用程序发生ANR（Application No Responding）错误时，Monkey是否停止运行。如果使用此参数，即使应用程序发生ANR错误，Monkey依然会发送事件，直到事件计数完成。</p>
</li>
<li><p>7) 参数：–ignore-security-exceptions<br>用于指定当应用程序发生许可错误时（如证书许可，网络许可等），Monkey是否停止运行。如果使用此参数，即使应用程序发生许可错误，Monkey依然会发送事件，直到事件计数完成。</p>
</li>
<li><p>8) 参数：–kill-process-after-error<br>用于指定当应用程序发生错误时，是否停止其运行。如果指定此参数，当应用程序发生错误时，应用程序停止运行并保持在当前状态（注意：应用程序仅是静止在发生错误时的状态，系统并不会结束该应用程序的进程）。</p>
</li>
<li><p>9) 参数：–monitor-native-crashes<br>用于指定是否监视并报告应用程序发生崩溃的本地代码。</p>
</li>
<li><p>10) 参数：–pct-｛+事件类别｝ ｛+事件类别百分比｝<br>用于指定每种类别事件的数目百分比（在Monkey事件序列中，该类事件数目占总事件数目的百分比）</p>
</li>
</ul>
<ul>
<li><p>–pct-touch ｛+百分比｝<br>调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)<br>adb shell monkey -p com.htc.Weather –pct-touch 10 1000</p>
</li>
<li><p>–pct-motion ｛+百分比｝<br>调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)adb shell monkey -p com.htc.Weather –pct-motion 20 1000</p>
</li>
<li><p>–pct-trackball ｛+百分比｝<br>调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)<br>adb shell monkey -p com.htc.Weather –pct-trackball 30 1000<br>–pct-nav ｛+百分比｝</p>
</li>
<li><p>调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)<br>adb shell monkey -p com.htc.Weather –pct-nav 40 1000</p>
</li>
<li><p>–pct-majornav ｛+百分比｝<br>调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键)<br>adb shell monkey -p com.htc.Weather –pct-majornav 50 1000</p>
</li>
<li><p>–pct-syskeys ｛+百分比｝<br>调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)<br>adb shell monkey -p com.htc.Weather –pct-syskeys 60 1000</p>
</li>
<li><p>–pct-appswitch ｛+百分比｝<br>调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法<br>adb shell monkey -p com.htc.Weather –pct-appswitch 70 1000</p>
</li>
<li><p>–pct-anyevent ｛+百分比｝<br>调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等<br>adb shell monkey -p com.htc.Weather</p>
</li>
<li><p>–pct -anyevent 100 1000* 指定多个类型事件的百分比：<br>adb shell monkey -p com.htc.Weather –pct-anyevent 50 –pct-appswitch 50 1000<br>注意：各事件类型的百分比总数不能超过100%；</p>
</li>
</ul>
</blockquote>
<p>###monkey之monkey日志分析</p>
<p>####一、初步分析方法：<br>Monkey测试出现错误后，一般的差错步骤为以下几步：</p>
<blockquote>
<ul>
<li>找到是monkey里面的哪个地方出错</li>
<li>查看Monkey里面出错前的一些事件动作，并手动执行该动作</li>
<li>若以上步骤还不能找出，可以使用之前执行的monkey命令再执行一遍，注意seed值要一样</li>
</ul>
</blockquote>
<p>####一般的测试结果分析：</p>
<blockquote>
<ul>
<li>ANR问题：在日志中搜索“ANR”</li>
<li>崩溃问题：在日志中搜索“Exception”<br>####二、详细分析monkey日志：<br>   首先我们需要查看Monkey测试中是否出现了ANR或者异常，具体方法如上述。将执行Monkey生成<br> 的log，从手机中导出并打开查看该log；<br>  在log的最开始都会显示Monkey执行的seed值、执行次数和测试的包名。具体方法如上述。<br>   然后我们要分析log中的具体信息，方法如下：<pre><code>查看log中第一个Switch，主要是查看Monkey执行的是那一个Activity，譬如下面的log中，
</code></pre> 执行的是com.tencent.smtt.SplashActivity，<br> 在下一个swtich之间的，如果出现了崩溃或其他异常，可以在该Activity中查找问题的所在。</li>
</ul>
</blockquote>
<p>:Switch:#Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;<br>launchFlags=0x10000000;component=com.tencent.smtt/.SplashActivity;<br>end// Allowing start of Intent {act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]cmp=com.tencent.smtt/.SplashActivity } in package com.tencent.smtt</p>
<p>在下面的log中，Sending Pointer ACTION_DOWN和Sending Pointer ACTION_UP代表当前执行了一个单击的操作；<br>Sleeping for 500 milliseconds这句log是执行Monkey测试时，throttle设定的间隔时间，每出现一次，就代表一个事件。<br>SendKey(ACTION_DOWN) //KEYCODE_DPAD_DOWN?代表当前执行了一个点击下导航键的操作；<br>Sending Pointer ACTION_MOVE代表当前执行了一个滑动界面的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">:Sending Pointer ACTION_DOWN x=47.0 y=438.0</div><div class="line">:Sending Pointer ACTION_UP x=47.0 y=438.0</div><div class="line">Sleeping for 500 milliseconds</div><div class="line">:SendKey (ACTION_DOWN): 20 //KEYCODE_DPAD_DOWN</div><div class="line">:SendKey (ACTION_UP): 20 //KEYCODE_DPAD_DOWN</div><div class="line">Sleeping for 500 milliseconds</div><div class="line">:Sending Pointer ACTION_MOVE x=-2.0 y=3.0</div><div class="line">:Sending Pointer ACTION_MOVE x=4.0 y=-3.0</div><div class="line">:Sending Pointer ACTION_MOVE x=-5.0 y=-3.0</div><div class="line">:Sending Pointer ACTION_MOVE x=3.0 y=4.0</div><div class="line">:Sending Pointer ACTION_MOVE x=-4.0 y=1.0</div><div class="line">:Sending Pointer ACTION_MOVE x=-1.0 y=-1.0</div><div class="line">:Sending Pointer ACTION_MOVE x=-2.0 y=-4.0</div></pre></td></tr></table></figure>
<p>如果Monkey测试顺利执行完成，在log的最后，会打印出当前执行事件的次数和所花费的时间；// Monkey finished代表执行完成。Monkey执行中断，在log的最后也能查看到当前已执行的次数。Monkey执行完成的log具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Events injected: 6000</div><div class="line">:Dropped: keys=0 pointers=9 trackballs=0 flips=0</div><div class="line">Network stats: elapsed time=808384ms (0ms mobile, 808384ms wifi, 0msnot connected)</div><div class="line">//Monkey finished</div></pre></td></tr></table></figure>
<p>##项目实践</p>
<blockquote>
<ul>
<li>安装安卓SDK 配置环境</li>
<li>连接真机或者模拟器</li>
<li>打开测试app</li>
<li>查看是否连接：adb devices<br>(连接成功图示)<br><img src="http://img.blog.csdn.net/20170927160702217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ul>
</blockquote>
<hr>
<p>没有apk，应用已经安装到手机或虚拟机中<br>1.logcat.清除logcat内容，使用命令adb logcat -c<br>.启动logcat，使用命令adb logcat ActivityManager:I *:s  启动要查看的程序，<br>2.dumpsys<br>（1）启动要查看的程序；<br>（2）命令行输入：<br>adb shell dumpsys window w |findstr \/ |findstr name=</p>
<hr>
<p>5.获取apk包名：adb shell dumpsys window w |findstr \/ |findstr name=</p>
<p><img src="http://img.blog.csdn.net/20170927160820485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>6.输入命令进行测试app<br>adb shell monkey -p com.hanfujia.shq -s 500 –ignore-crashes –ignore-timeouts –monitor-native-crashes -v -v 10000 &gt; E:\monkey_log.txt<br>产生时间序列的种子值：500<br>忽略程序崩溃 、 忽略超时 、 监视本地程序崩溃 、 详细信息级别为2 ， 产生 10000个事件<br>monkey作用的包：com.hanfujia.shq<br>7.查看log并截取CRASH处log发给开发工程师</p>
]]></content>
      
        <categories>
            
            <category> Monkey测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> Monkey </tag>
            
            <tag> 移动端测试 </tag>
            
            <tag> 压力测试 </tag>
            
            <tag> 稳定性测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Linux学习（一）--基本概念]]></title>
      <url>/2017/09/25/%E5%8E%9F-Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h2 id="一、Linux概述"><a href="#一、Linux概述" class="headerlink" title="一、Linux概述"></a>一、Linux概述</h2><pre><code>Linux是一款全球性的免费的开源的操作系统平台，其特点是实现了多任务多用户处理，主要是依赖
内核kernel shell，且占用资源少
（最小配置只要4Mb内存就能运行）。
</code></pre><a id="more"></a>
<h3 id="百度百科概述"><a href="#百度百科概述" class="headerlink" title="百度百科概述"></a>百度百科概述</h3><pre><code>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任
务、支持多线程和多CPU的操作系统。
它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。
Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不
同的Linux版本，但它们都使用了Linux内核。
Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算
机、大型机和超级计算机。
   严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个
基于Linux内核，
并且使用GNU工程各种工具和数据库的操作系统。
</code></pre><h4 id="1-1由来"><a href="#1-1由来" class="headerlink" title="1.1由来"></a>1.1由来</h4><pre><code>类UNIX的，与UNIX都是服务器系统。
</code></pre><h4 id="1-2与UNIX的区别"><a href="#1-2与UNIX的区别" class="headerlink" title="1.2与UNIX的区别"></a>1.2与UNIX的区别</h4><pre><code>Linux是免费开源的，UNIX是商业应用性软件操作系统，UNIX是与硬件进行捆绑销售的，UNIX是不
开源的（部分开源，但是核心代码是不开源的）
</code></pre><h4 id="1-3-版本"><a href="#1-3-版本" class="headerlink" title="1.3.版本"></a>1.3.版本</h4><pre><code>主要分为两大类：商业版、社区版
1)red hat：红帽（全球唯一一家认证Linux能力的公司，占据了Linux市场的绝大部分）
2)Fedora：免费开源社区版本
3)centos：community enterprise （稳定性要优于fedora）
4)redhat enterprise：
5)debian：容错性极强的操作系统，但是系统分区过于复杂
6)ubuntu：由乌班图转义而来：仁和；南非（祖鲁或者豪萨）：人性  
口号：我的存在是因为你们的存在。
倾向于桌面操作系统（图形界面），一般不用于服务器
7）suse：德国，很好地实现与各种数据库兼容，能够实现自动分区
</code></pre><h4 id="1-4-安装"><a href="#1-4-安装" class="headerlink" title="1.4 安装"></a>1.4 安装</h4><pre><code>分为图形化界面版本和Linux 文本版本
</code></pre><h5 id="1-4-1Linux核心："><a href="#1-4-1Linux核心：" class="headerlink" title="1.4.1Linux核心："></a>1.4.1Linux核心：</h5><pre><code>1)Linux中没有盘符的概念，所有的一切都称为文件（目录、文件夹、文件、操作系统、应用程序等）；
2)只要能装到Linux系统上的软件，则都称为有用途软件
</code></pre><h5 id="1-4-2-分区（树状结构）"><a href="#1-4-2-分区（树状结构）" class="headerlink" title="1.4.2.分区（树状结构）"></a>1.4.2.分区（树状结构）</h5><pre><code>1)根分区：使用“/”表示，必须要有
挂载：所有目录都是挂载在分区上面的
2)引导分区：也叫做boot分区，用“/boot”表示，相当于windows中的BIOS引导盘。没有的话系统无法启动。
必须存在，容量在50-100M，用于存储系统主核心shell程序
3)swap分区：又称为交换分区，当物理内存中的链接过多内存不够的时候，将多余的链接放到swap分区中，
等物理内存中压力缓解之后再将swap中的链接放到物理内存中进行处理。用户无法进行访问，
大小通常为物理内存的两倍
</code></pre><h5 id="1-4-3-文件类型："><a href="#1-4-3-文件类型：" class="headerlink" title="1.4.3.文件类型："></a>1.4.3.文件类型：</h5><pre><code>ext3、swap
</code></pre><h5 id="1-4-4-补充"><a href="#1-4-4-补充" class="headerlink" title="1.4.4.补充"></a>1.4.4.补充</h5><blockquote>
<ul>
<li>安全模式：只加载系统启动最基本的设置</li>
<li>虚拟内存：指在物理内存不够用的时候使用设置的虚拟内存暂时存储后续的数据以缓解物理内存压力，不至于系统内存崩溃，范围在物理内存的1-1.5倍</li>
</ul>
</blockquote>
<h5 id="1-4-5-解析"><a href="#1-4-5-解析" class="headerlink" title="1.4.5.解析"></a>1.4.5.解析</h5><pre><code>[root@localhost ~]#：root表示当前用户；localhost表示本机；
~表示当前用户目录；#表示管理员登陆（$表示普通用户登陆）
</code></pre><h5 id="1-4-6-从text界面进入图形化界面："><a href="#1-4-6-从text界面进入图形化界面：" class="headerlink" title="1.4.6.从text界面进入图形化界面："></a>1.4.6.从text界面进入图形化界面：</h5><pre><code>startx
</code></pre><h5 id="从图形化界面回到text界面："><a href="#从图形化界面回到text界面：" class="headerlink" title="从图形化界面回到text界面："></a>从图形化界面回到text界面：</h5><pre><code>system注销（logout）
</code></pre><h2 id="二、文件系统"><a href="#二、文件系统" class="headerlink" title="二、文件系统"></a>二、文件系统</h2><h3 id="2-1文件类型"><a href="#2-1文件类型" class="headerlink" title="2.1文件类型"></a>2.1文件类型</h3><h4 id="2-1-1普通文件（regular-file）"><a href="#2-1-1普通文件（regular-file）" class="headerlink" title="2.1.1普通文件（regular file）"></a>2.1.1普通文件（regular file）</h4><pre><code>就是一般存取的文件，由ls -al显示出来的属性中，第一个属性为 [-]，例如 [-rwxrwxrwx]。
另外，依照文件的内容，又大致可以分为：
   1）纯文本文件（ASCII）：这是Unix系统中最多的一种文件类型，之所以称为纯文本文件，
是因为内容可以直接读到的数据，例如数字、字母等等。
设 置文件几乎都属于这种文件类型。举例来说，使用命令“cat ~/.bashrc”
就可以看到该文件的内容（cat是将文件内容读出来）。
   2）二进制文件（binary）：系统其实仅认识且可以执行二进制文件（binary file）。
Linux中的可执行文件（脚本，文本方式的批处理文件不算）就是这种格式的。
举例来说，命令cat就是一个二进制文件。
   3）数据格式的文件（data）：有些程序在运行过程中，会读取某些特定格式的文件，
那些特定格式的文件可以称为数据文件（data file）。
举例来说，Linux在用户登入时，都会将登录数据记录在 /var/log/wtmp文件内，该文件是一个数据文件，
它能通过last命令读出来。但使用cat时，会读出乱码。因为它是属于一种特殊格式的文件。
</code></pre><h4 id="2-1-2目录文件（directory）"><a href="#2-1-2目录文件（directory）" class="headerlink" title="2.1.2目录文件（directory）"></a>2.1.2目录文件（directory）</h4><pre><code>就是目录，第一个属性为 [d]，例如 [drwxrwxrwx]。
</code></pre><h4 id="2-1-3连接文件（link）"><a href="#2-1-3连接文件（link）" class="headerlink" title="2.1.3连接文件（link）"></a>2.1.3连接文件（link）</h4><pre><code>类似Windows下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrwx]。
</code></pre><h4 id="2-1-4设备与设备文件（device）"><a href="#2-1-4设备与设备文件（device）" class="headerlink" title="2.1.4设备与设备文件（device）"></a>2.1.4设备与设备文件（device）</h4><pre><code>与系统外设及存储等相关的一些文件，通常都集中在 /dev目录。通常又分为两种：
</code></pre><h4 id="2-1-5块设备文件"><a href="#2-1-5块设备文件" class="headerlink" title="2.1.5块设备文件"></a>2.1.5块设备文件</h4><pre><code>就是存储数据以供系统存取的接口设备，简单而言就是硬盘。
例如一号硬盘的代码是 /dev/hda1等文件。第一个属性为 [b]。
</code></pre><h4 id="2-1-6字符设备文件"><a href="#2-1-6字符设备文件" class="headerlink" title="2.1.6字符设备文件"></a>2.1.6字符设备文件</h4><pre><code>即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为[c] 。
</code></pre><h4 id="2-1-7套接字（sockets）"><a href="#2-1-7套接字（sockets）" class="headerlink" title="2.1.7套接字（sockets）"></a>2.1.7套接字（sockets）</h4><pre><code>这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接
字来进行数据通信。
第一个属性为 [s]，最常在 /var/run目录中看到这种文件类型。
</code></pre><h4 id="2-1-8管道（FIFO-pipe）"><a href="#2-1-8管道（FIFO-pipe）" class="headerlink" title="2.1.8管道（FIFO,pipe）"></a>2.1.8管道（FIFO,pipe）</h4><pre><code>FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。
FIFO是first-in-first-out（先进先出）的缩写。第一个属性为[p] 。
</code></pre><h3 id="2-2文件结构"><a href="#2-2文件结构" class="headerlink" title="2.2文件结构"></a>2.2文件结构</h3><table>
<thead>
<tr>
<th style="text-align:left">目录名称</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bin</td>
<td style="text-align:left">基本命令目录（绿色表示可执行）</td>
</tr>
<tr>
<td style="text-align:left">dev</td>
<td style="text-align:left">设备文件目录</td>
</tr>
<tr>
<td style="text-align:left">tty</td>
<td style="text-align:left">终端串行设备</td>
</tr>
<tr>
<td style="text-align:left">home</td>
<td style="text-align:left">主目录，创建用户的时候会在该目录下自动创建一个同名的目录</td>
</tr>
<tr>
<td style="text-align:left">lost+found</td>
<td style="text-align:left">当出现系统数据丢失（比如断电）时会将数据保存在该目录下</td>
</tr>
<tr>
<td style="text-align:left">net</td>
<td style="text-align:left">网络文件目录(网络设置目录、存放网络通讯相关软件)</td>
</tr>
<tr>
<td style="text-align:left">misc</td>
<td style="text-align:left">空目录</td>
</tr>
<tr>
<td style="text-align:left">proc</td>
<td style="text-align:left">进程或内存使用信息（任务管理的相关信息）</td>
</tr>
<tr>
<td style="text-align:left">sbin</td>
<td style="text-align:left">高级命令目录</td>
</tr>
<tr>
<td style="text-align:left">srv</td>
<td style="text-align:left">空目录</td>
</tr>
<tr>
<td style="text-align:left">tftpboot</td>
<td style="text-align:left">ftp信息存放在该目录中（ftp根目录）</td>
</tr>
<tr>
<td style="text-align:left">usr</td>
<td style="text-align:left">软件安装时默认安装目录</td>
</tr>
<tr>
<td style="text-align:left">boot</td>
<td style="text-align:left">内核程序、引导分区程序</td>
</tr>
<tr>
<td style="text-align:left">etc</td>
<td style="text-align:left">配置文件目录（shift+pageup/pagedown  页面上翻/下翻）</td>
</tr>
<tr>
<td style="text-align:left">lib</td>
<td style="text-align:left">类库</td>
</tr>
<tr>
<td style="text-align:left">media</td>
<td style="text-align:left">媒体目录</td>
</tr>
<tr>
<td style="text-align:left">mnt</td>
<td style="text-align:left">光驱挂载点目录（将光驱中的资源挂载到该目录中）</td>
</tr>
<tr>
<td style="text-align:left">opt</td>
<td style="text-align:left">操作的文件信息</td>
</tr>
<tr>
<td style="text-align:left">root</td>
<td style="text-align:left">root用户/管理员目录</td>
</tr>
<tr>
<td style="text-align:left">SElinux</td>
<td style="text-align:left">Linux shell主配置文件目录</td>
</tr>
<tr>
<td style="text-align:left">sys</td>
<td style="text-align:left">系统目录</td>
</tr>
<tr>
<td style="text-align:left">tmp</td>
<td style="text-align:left">临时目录，用于存放垃圾文件</td>
</tr>
<tr>
<td style="text-align:left">var</td>
<td style="text-align:left">缓存、临时数据、临时变量存放在该目录中</td>
</tr>
</tbody>
</table>
<h3 id="2-3常用命令及技巧"><a href="#2-3常用命令及技巧" class="headerlink" title="2.3常用命令及技巧"></a>2.3常用命令及技巧</h3><table>
<thead>
<tr>
<th style="text-align:left">命令/用途</th>
<th style="text-align:left">用途/命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">查看文件、文件夹</td>
<td style="text-align:left">dir</td>
</tr>
<tr>
<td style="text-align:left">显示文件内容</td>
<td style="text-align:left">cat文件名</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">表示root用户目录、宿主目录</td>
</tr>
<tr>
<td style="text-align:left">cd    /</td>
<td style="text-align:left">进入根目录（ /表示根目录）</td>
</tr>
<tr>
<td style="text-align:left">ls</td>
<td style="text-align:left">表示显示全部文件</td>
</tr>
<tr>
<td style="text-align:left">ls  -l</td>
<td style="text-align:left">表示显示文件详细信息</td>
</tr>
<tr>
<td style="text-align:left">ls  -a</td>
<td style="text-align:left">表示显示文件包括隐藏文件的详细信息</td>
</tr>
<tr>
<td style="text-align:left">dir –a</td>
<td style="text-align:left">同上（无颜色）</td>
</tr>
<tr>
<td style="text-align:left">pwd</td>
<td style="text-align:left">表示显示当前目录所在路径</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">表示管理员登陆</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">表示普通用户登陆</td>
</tr>
<tr>
<td style="text-align:left">显示当前工作目录</td>
<td style="text-align:left">pwd</td>
</tr>
<tr>
<td style="text-align:left">显示当前目录中的文件</td>
<td style="text-align:left">ls 或dir</td>
</tr>
<tr>
<td style="text-align:left">切换目录</td>
<td style="text-align:left">cd</td>
</tr>
<tr>
<td style="text-align:left">切换到root目录</td>
<td style="text-align:left">cd ~ 或cd /root</td>
</tr>
<tr>
<td style="text-align:left">切换到根目录</td>
<td style="text-align:left">cd /</td>
</tr>
<tr>
<td style="text-align:left">切换到上级目录</td>
<td style="text-align:left">cd ..</td>
</tr>
<tr>
<td style="text-align:left">切换到当前目录</td>
<td style="text-align:left">cd .</td>
</tr>
<tr>
<td style="text-align:left">创建文件夹</td>
<td style="text-align:left">mkdir</td>
</tr>
<tr>
<td style="text-align:left">删除文件夹</td>
<td style="text-align:left">rmdir（不能直接删除不为空的目录）</td>
</tr>
<tr>
<td style="text-align:left">创建文件</td>
<td style="text-align:left">vi 或 vim 文件名.后缀</td>
</tr>
<tr>
<td style="text-align:left">关机</td>
<td style="text-align:left">shutdown/poweroff/halt</td>
</tr>
<tr>
<td style="text-align:left">重启</td>
<td style="text-align:left">reboot</td>
</tr>
<tr>
<td style="text-align:left">注销</td>
<td style="text-align:left">logout、exit</td>
</tr>
<tr>
<td style="text-align:left">vi 文件名.后缀按“i”（进入插入模式）</td>
<td style="text-align:left">vi</td>
</tr>
<tr>
<td style="text-align:left">保存并退出</td>
<td style="text-align:left">:wq</td>
</tr>
<tr>
<td style="text-align:left">不保存退出</td>
<td style="text-align:left">:q</td>
</tr>
<tr>
<td style="text-align:left">强制退出</td>
<td style="text-align:left">:q!</td>
</tr>
<tr>
<td style="text-align:left">去除插入模式</td>
<td style="text-align:left">按esc</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（二）--数据库的语法]]></title>
      <url>/2017/09/21/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="关于数据库的语法："><a href="#关于数据库的语法：" class="headerlink" title="关于数据库的语法："></a>关于数据库的语法：</h4><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h4><p>create database   数据库名 </p>
<p>on primary </p>
<pre><code>（主文件属性（name，filename，size等）） 
</code></pre><ul>
<li><p>-用逗号隔开次要主要文件和次要文件 </p>
<p>   (次要文件属性(name,filename,size等)) </p>
</li>
</ul>
<p>log on </p>
<pre><code>（日志文件属性（name，filename，size等））
</code></pre><a id="more"></a>
<h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><p>`create database student </p>
<p>on primary( </p>
<p>name=”student”, </p>
<p>filename=”E:\SQL_test\student”, </p>
<p>size=5MB, </p>
<p>maxsize=20MB, </p>
<p>filegrowth=1MB </p>
<p>) </p>
<p>log on( </p>
<p>name=”studeng_log”, </p>
<p>filename=”E:\SQL_test\student_log”, </p>
<p>size=3MB </p>
<p>)`</p>
<hr>
<p>===============================================</p>
<h4 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h4><pre><code>Name为逻辑名称，相当于逻辑路径（相对路径）主要运用于数据库开发人员在使用数据库过程中进行的引用
Filename：物理名称，相当于绝对路径，主要用于进行数据库数据的实际存储地址
</code></pre><h4 id="编写数据库代码的注意事项："><a href="#编写数据库代码的注意事项：" class="headerlink" title="编写数据库代码的注意事项："></a>编写数据库代码的注意事项：</h4><pre><code>1.所有的编码过程中都必须在英文状态下进行 

   2.所有的属性都必须写在小括号内，属性与属性之间用逗号隔开，最后一个属性不用加逗号 

   3.在sqlserver中，关键字不区分大小写，但是内容区分大小写，值的单位也不区分大小写（如mb和MB） 

   4.值必须用单引号 ‘’引起来 

   5.值可以使用两种方式，一种以兆数，一种以百分比 

   6.逻辑名是绝对不可以重名的 

   7.切换数据库，use +数据库名 

   8.创建数据库，create  database 数据库名
</code></pre><h4 id="关于文件语法："><a href="#关于文件语法：" class="headerlink" title="关于文件语法："></a>关于文件语法：</h4><pre><code>1.添加文件语法
   Alter database 数据库名
   Add file（添加文件的文件属性信息）
2.删除文件语法：alter（修改）
  alter database 数据库名
  remove  file 文件名
3.查找数据库文件语法：Execute（执行）
  Exec  sp_helpfile 数据库中所存在的文件名，
如果不接数据库所在的文件名的话则显示该数据库中的所有文件信息
4.修改数据库的文件信息语法：modify（修改）

Alter  database  student
Modify  file（
Name=’student’,
Size=3MB,
Filegroweth=20%
)

5.数据库的重命名：
  Exec sp_renamedb  旧名称,新名称
6.文件名的重命名：


Alter  database  student
Modify  file（
Name=’student2’,
Newname=’student3’
)

7.添加文件组：
  Alter  database  student
  Add  filegroup 组名
8.删除文件组语法：alter（修改）
  alter database 数据库名
  remove  filegroup 文件组名
9.查找数据库文件语法： 
  Exec  sp_helpfilegroup
10.将文件添加到文件组：
Alter  database 数据库名
Add  file （
Name=’学生’,
Filename=’e:\xuesheng.ndf’
)to  filegroup  组名
</code></pre><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><pre><code>--创建学生数据库
create database student
on primary(  
name=&quot;student&quot;,
filename=&quot;F:\Micro SQL Express\workplace\student&quot;,
size=5MB,
maxsize=20MB,
filegrowth=1MB
)
log on(
name=&quot;student_log&quot;,
filename=&quot;F:\Micro SQL Express\workplace\student_log&quot;,
size=5MB
)

--切换数据库
use student
</code></pre><p>–数据库文件的增、删、改、查<br>–添加文件 ADD<br>    alter database student<br>    add file(<br>    name=”test_file_3”,<br>    filename=”F:\Micro SQL Express\workplace\test_file_3”,<br>    size=1MB<br>    )</p>
<p>–修改文件 MODIFY<br>alter database student<br>modify file(<br>name=”test_file”,<br>size=4MB,<br>filegrowth=10%<br>)</p>
<p>–查找数据库文件<br>exec sp_helpfile test_file</p>
<p>–删除文件 drop<br>alter database student<br>remove file test_file</p>
<p>–重命名<br>–数据库重命名<br>exec sp_renamedb student,newstudent<br>exec sp_renamedb newstudent,student<br>–文件重命名<br>alter database student<br>modify file(<br>name=”test_file”,<br>newname=”new_test_file”<br>)</p>
<p>alter database student<br>modify file(<br>name=”new_test_file”,<br>newname=”test_file”<br>)</p>
<p>exec sp_helpfile new_test_file</p>
<p>–添加文件组<br>alter database student<br>add filegroup class_B</p>
<p>–添加文件到组内<br>alter database student<br>add file(<br>name=”test_file_4”,<br>filename=”F:\Micro SQL Express\workplace\test_file_4”<br>)to filegroup class_A</p>
<p>–查找文件组<br>exec sp_helpfilegroup class_A</p>
<p>–删除文件组<br>alter database student<br>remove filegroup class_B</p>
<p>```</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Microsoft SQL Server学习（一）--基本概念]]></title>
      <url>/2017/09/21/%E5%8E%9F-Microsoft-SQL-Server%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>###数据库的分类：</p>
<p>####1.关系型数据库:</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据库名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">公司</th>
<th style="text-align:left">平台</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Access</td>
<td style="text-align:left">小型数据库</td>
<td style="text-align:left">微软</td>
<td style="text-align:left">Windows</td>
</tr>
<tr>
<td style="text-align:left">Mysql</td>
<td style="text-align:left">小型数据库</td>
<td style="text-align:left">AB–sun–甲骨文</td>
<td style="text-align:left">Windows/linux/mac</td>
</tr>
<tr>
<td style="text-align:left">sqlserver</td>
<td style="text-align:left">中型数据库</td>
<td style="text-align:left">微软</td>
<td style="text-align:left">Windows</td>
</tr>
<tr>
<td style="text-align:left">sybase</td>
<td style="text-align:left">中型数据库</td>
<td style="text-align:left">unix</td>
<td style="text-align:left">Sybase公司</td>
</tr>
<tr>
<td style="text-align:left">oracle</td>
<td style="text-align:left">大型数据库</td>
<td style="text-align:left">甲骨文</td>
<td style="text-align:left">Windows/linux/mac</td>
</tr>
<tr>
<td style="text-align:left">DB2</td>
<td style="text-align:left">大型数据库</td>
<td style="text-align:left">IBM</td>
<td style="text-align:left">Windows</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>####2.非关系型数据库:<br>    NOSQL（SQLite、Redis、MongoDB、Cassandra）</p>
<p>####3.数据库的发展：<br>    数据库的发展：人工阶段文件系统阶段倒排文件系统阶段(在文件系统阶段基础上提高了数据的检索速度)</p>
<p>####4.数据都是以文件的形式存储在硬盘上。(FAT、FAT32、NTFS) Linux(EXT)</p>
<p>####5.数据库设计流程:<br>          概念设计：E-R图( entity relationship model 实体关系模型图)<br>          使用图形符号等形式进行表示需求中的实体与实体之间的联系，<br>     从而便于后期数据库设计人员进行逻辑设计。<br>          逻辑设计：<br>          物理设计： 根据逻辑设计写代码<br>          实施：    部署（执行代码）<br>          维护：    实现对数据库结构的更新和修改</p>
<p>####6.文件系统缺陷：<br>            1) 数据的冗余性（重复的数据）<br>            2) 数据的一致性(前台页面所传入的数据与后台实际存储的数据是否一致)<br>            3) 数据的正确性（数据类型的定义）</p>
<p>####7.数据库的专业术语：<br>        DBA    database administrator 数据库管理人员<br>        DB       database 数据库：用于进行动态存储数据的容器<br>        DBS       database system 数据库系统： 由多个数据库构成<br>        DBMS   database manager system 数据库管理系统：针对用户<br>        进行实现对数据库的增、删、改、查等一系列操作的管理软件。</p>
<p>####8.数据库引擎服务<br>       用于存储、处理和保护数据的核心服务，数据库引擎提供受控访问和快速事务处理，<br>    还提供丰富的支持以获得持续的高可用性。共享功能是由计算机上所有的SQL Server实例使用，<br>    这些功能只在计算机上安装一次服务器功能可识别实例且有自己的注册表配置单元，<br>    他们支持在一台计算上有多个实例</p>
<p>####9.E-R图使用方式：<br>    使用矩形进行表示实体，使用椭圆进行表示属性，实体与属性或者实体与联系之间都是使用无向边<br>    进行连接，实体与实体之间存在联系，联系使用菱形表示。<br>    E-R联系主要存在三种：1对1   1对多<br>    多对多注：E-R图要有联系的文字说明或者符号说明。</p>
<hr>
<p>###数据库的常用概念</p>
<p>####1.概念</p>
<pre><code>&gt;实体（entity）：客观存在的事物或者是抽象事件（例如：一架飞机….）
&gt;事物（客观存在的物体或者是抽象事件）
&gt;事务（处理一系列相关事件的过程以及执行的动作）
&gt;属性（property）：实体所具有固定的特征即数据的描述（例如：飞机（重量、长、宽、高））【属性也叫字段】
&gt;属性值（property value）：属性中对应的值（又称字段值）
&gt;实体值（entity value）：每个实体所具有相同属性对应值的集合
&gt;实体型（entity type）：所有实体所具有共同的类型特征（例如：一个学生：学号、性别、年龄、姓名）
&gt;实体集（entity ）：实体型与实体共同的集合
&gt;码：在所有实体中的所有属性所选取的某一字段作为唯一标识得属性称为码（例如：身份证或者学生中的学号）
</code></pre><p>####2.连接本地数据库有五种：<br>      ①.<br>      ②local host<br>      ③127.0.0.1（环回地址）<br>      ④本机IP地址<br>      ⑤本机计算机名<br>      连接其他计算机只有两种<br>      ①IP地址<br>      ②计算机名</p>
<h4 id="3-系统自带的四大数据库（必须存在）："><a href="#3-系统自带的四大数据库（必须存在）：" class="headerlink" title="3.系统自带的四大数据库（必须存在）："></a>3.系统自带的四大数据库（必须存在）：</h4><pre><code>Master数据库：主数据库：主要用于进行存储其他数据库信息
Model数据库：模板数据库，用于直接创建数据库时所作为的模板，所有的数据库属性值都 参照于当前模板
Msdb数据库：备份与配置数据库，所有数据库的配置信息都存储在该数据中
Tempdb数据库：临时数据库，进行数据应用过程中所产生的临时数据将存入到临时数据库中
</code></pre><p>####4.在sqlserver当中主要存在的文件类型主要有哪些：<br>      主文件（.mdf），必须有且只有一个,默认值大小为3M<br>      日志文件（.ldf），至少存在一个<br>      次要文件（.ndf），可有可无</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> SQLServer </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]python自动化测试框架（一）]]></title>
      <url>/2017/09/21/%E5%8E%9F-python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h4><table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>   系统</td>
<td>windows 7</td>
</tr>
<tr>
<td>   python版本</td>
<td>2.7.14</td>
</tr>
<tr>
<td>   IDE</td>
<td>pycharm2017</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="2-大致框架流程"><a href="#2-大致框架流程" class="headerlink" title="2.大致框架流程"></a>2.大致框架流程</h4><p>：展示了框架实现的业务流程 </p>
<p><img src="http://img.blog.csdn.net/20170921111241156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYxNTUzNDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="自动化流程图"></p>
<h4 id="3-框架介绍"><a href="#3-框架介绍" class="headerlink" title="3.框架介绍"></a>3.框架介绍</h4><h5 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h5><p>======完善中========</p>
]]></content>
      
        <categories>
            
            <category> Python自动化测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> Python </tag>
            
            <tag> 接口自动化测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[转]Appium Python API 汇总]]></title>
      <url>/2017/07/10/%E8%BD%AC-Appium-Python-API-%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p><span style="color:#660000"><span style="font-family:微软雅黑,&quot;Microsoft YaHei&quot;; font-size:24px">最近在学习Python自动化，</span><span style="font-family:微软雅黑,&quot;Microsoft YaHei&quot;; font-size:24px">网络搜集而来，留着备用，</span></span></p>
<p><span style="font-family:微软雅黑,Microsoft YaHei; font-size:24px"><span style="font-family:微软雅黑,&quot;Microsoft YaHei&quot;; font-size:24px"><span style="color:#660000">方便自己也方便他人。感谢总结的人！</span></span></span></p>
<p>##<br><a id="more"></a></p>
<p>##<br>1.contexts</p>
<p>contexts(self):</p>
<p>&nbsp;&nbsp;&nbsp; Returns the contexts within the current session.</p>
<p>&nbsp;&nbsp;&nbsp; 返回当前会话中的上下文，使用后可以识别H5页面的控件</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.contexts</p>
<p>用法 driver.contexts</p>
<p>##<br>2. current_context</p>
<p>current_context(self):</p>
<p>&nbsp;&nbsp;&nbsp; Returns the current context of the current session.</p>
<p>&nbsp;&nbsp;&nbsp; 返回当前会话的当前上下文</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.current_context</p>
<p>用法driver. current_context</p>
<p>##<br>3. context</p>
<p>context(self):</p>
<p>&nbsp;&nbsp;&nbsp; Returns the current context of the current session.</p>
<p>&nbsp;&nbsp;&nbsp; 返回当前会话的当前上下文。</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver.context</p>
<p>用法driver. Context</p>
<p>##<br>4. find_element_by_ios_uiautomation</p>
<p>find_element_by_ios_uiautomation(self, uia_string):</p>
<p>Finds an element by uiautomation in iOS.</p>
<p>&nbsp;&nbsp;&nbsp; 通过iOS uiautomation查找元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - uia_string - The element name in the iOS UIAutomation library</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.find_element_by_ios_uiautomation(‘.elements()[1].cells()[2]’)</p>
<p>用法dr. find_element_by_ios_uiautomation(‘elements’)</p>
<p>##<br>5. find_element_by_accessibility_id</p>
<p>find_element_by_accessibility_id(self, id):</p>
<p>Finds an element by accessibility id.</p>
<p>&nbsp;&nbsp;&nbsp; 通过accessibility id查找元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - id - a string corresponding to a recursive element search using the</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; Id/Name that the native Accessibility options utilize</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.find_element_by_accessibility_id()</p>
<p>用法driver.find_element_by_accessibility_id(‘id’)</p>
<p>##<br>6.scroll</p>
<p>scroll(self, origin_el, destination_el):</p>
<p>Scrolls from one element to another</p>
<p>&nbsp;&nbsp;&nbsp; 从元素origin_el滚动至元素destination_el</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - originalEl - the element from which to being scrolling</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - destinationEl - the element to scroll to</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.scroll(el1, el2)</p>
<p>用法 driver.scroll(el1,el2)</p>
<p>##<br>7. drag_and_drop</p>
<p>drag_and_drop(self, origin_el, destination_el):</p>
<p>Drag the origin element to the destination element</p>
<p>&nbsp;&nbsp;&nbsp; 将元素origin_el拖到目标元素destination_el</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - originEl - the element to drag</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - destinationEl - the element to drag to</p>
<p>用法 driver.drag_and_drop(el1,el2)</p>
<p>##<br>8.tap</p>
<p>tap(self, positions, duration=None):</p>
<p>Taps on an particular place with up to five fingers, holding for a certain time</p>
<p>模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - positions - an array of tuples representing the x/y coordinates of</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; the fingers to tap. Length can be up to five.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - duration - (optional) length of time to tap, in ms</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.tap([(100, 20), (100, 60), (100, 100)], 500)</p>
<p>用法 driver.tap([(x,y),(x1,y1)],500)</p>
<p>##<br>9. swipe</p>
<p>swipe(self, start_x, start_y, end_x, end_y, duration=None):</p>
<p>Swipe from one point to another point, for an optional duration.</p>
<p>&nbsp;&nbsp;&nbsp; 从A点滑动至B点，滑动时间为毫秒</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - start_x - x-coordinate at which to start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - start_y - y-coordinate at which to start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - end_x - x-coordinate at which to stop</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - end_y - y-coordinate at which to stop</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - duration - (optional) time to take the swipe, in ms.</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.swipe(100, 100, 100, 400)</p>
<p>用法 driver.swipe(x1,y1,x2,y2,500)</p>
<p>##<br>10.flick</p>
<p>flick(self, start_x, start_y, end_x, end_y):</p>
<p>Flick from one point to another point.</p>
<p>&nbsp;&nbsp;&nbsp; 按住A点后快速滑动至B点</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - start_x - x-coordinate at which to start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - start_y - y-coordinate at which to start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - end_x - x-coordinate at which to stop</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - end_y - y-coordinate at which to stop</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.flick(100, 100, 100, 400)</p>
<p>用法 driver.flick(x1,y1,x2,y2)</p>
<p>##<br>11.pinch</p>
<p>pinch(self, element=None, percent=200, steps=50):</p>
<p>Pinch on an element a certain amount</p>
<p>&nbsp;&nbsp;&nbsp; 在元素上执行模拟双指捏（缩小操作）</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - element - the element to pinch</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - percent - (optional) amount to pinch. Defaults to 200%</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - steps - (optional) number of steps in the pinch action</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.pinch(element)</p>
<p>用法 driver.pinch(element)</p>
<p>##<br>12.zoom</p>
<p>zoom(self, element=None, percent=200, steps=50):</p>
<p>Zooms in on an element a certain amount</p>
<p>&nbsp;&nbsp;&nbsp; 在元素上执行放大操作</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;- element - the element to zoom</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - percent - (optional) amount to zoom. Defaults to 200%</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - steps - (optional) number of steps in the zoom action</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.zoom(element)</p>
<p>用法 driver.zoom(element)</p>
<p>##<br>13.reset</p>
<p>reset(self):</p>
<p>Resets the current application on the device.</p>
<p>重置应用(类&#20284;删除应用数据)</p>
<p>用法 driver.reset()</p>
<p><strong><span style="font-size:14px">14. hide_keyboard</span></strong></p>
<p>hide_keyboard(self, key_name=None, key=None, strategy=None):</p>
<p>Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.</p>
<p>&nbsp;&nbsp;&nbsp; 隐藏键盘,iOS使用key_name隐藏，安卓不使用参数</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - key_name - key to press</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</p>
<p>driver.hide_keyboard()</p>
<p>##<br>15. keyevent</p>
<p>keyevent(self, keycode, metastate=None):</p>
<p>Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/KeyEvent.html</a>.</p>
<p>&nbsp;&nbsp;&nbsp; 发送按键码（安卓仅有），按键码可以上网址中找到</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - keycode - the keycode to be sent to the device</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - metastate - meta information about the keycode being sent</p>
<p>用法 dr.keyevent(‘4’)</p>
<p>##<br>16. press_keycode</p>
<p>press_keycode(self, keycode, metastate=None):</p>
<p>Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/KeyEvent.html</a>.</p>
<p>&nbsp;&nbsp;&nbsp; 发送按键码（安卓仅有），按键码可以上网址中找到</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - keycode - the keycode to be sent to the device</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - metastate - meta information about the keycode being sent</p>
<p>用法 driver.press_ keycode(‘4’)</p>
<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>
<p>##<br>17. long_press_keycode</p>
<p>long_press_keycode(self, keycode, metastate=None):</p>
<p>Sends a long press of keycode to the device. Android only. Possible keycodes can be</p>
<p>&nbsp;&nbsp;&nbsp; found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/KeyEvent.html</a>.</p>
<p>&nbsp; &nbsp;&nbsp;发送一个长按的按键码（长按某键）</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - keycode - the keycode to be sent to the device</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - metastate - meta information about the keycode being sent</p>
<p>&nbsp;用法 driver.long_press_keycode(‘4’)</p>
<p><strong><span style="font-size:14px">18.current_activity</span></strong></p>
<p>current_activity(self):</p>
<p>Retrieves the current activity on the device.</p>
<p>获取当前的activity</p>
<p>用法 print(driver.current_activity())</p>
<p>##<br>19. wait_activity</p>
<p>wait_activity(self, activity, timeout, interval=1):</p>
<p>Wait for an activity: block until target activity presents or time out.</p>
<p>&nbsp;&nbsp;&nbsp; This is an Android-only method.</p>
<p>&nbsp;&nbsp;&nbsp; 等待指定的activity出现直到超时，interval为扫描间隔1秒</p>
<p>即每隔几秒获取一次当前的activity</p>
<p>返回的True 或 False</p>
<p>&nbsp;&nbsp;&nbsp; :Agrs:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - activity - target activity</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - timeout - max wait time, in seconds</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - interval - sleep interval between retries, in seconds</p>
<p>用法driver.wait_activity(‘.activity.xxx’,5,2)</p>
<p>##<br>20. background_app</p>
<p>background_app(self, seconds):</p>
<p>Puts the application in the background on the device for a certain duration.</p>
<p>&nbsp;&nbsp;&nbsp; 后台运行app多少秒</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - seconds - the duration for the application to remain in the background</p>
<p>用法 driver.background_app(5)&nbsp;&nbsp; 置后台5秒后再运行</p>
<p>##<br>21.is_app_installed</p>
<p>is_app_installed(self, bundle_id):</p>
<p>Checks whether the application specified by <code>bundle_id</code> is installed on the device.</p>
<p>&nbsp;&nbsp;&nbsp; 检查app是否有安装</p>
<p>返回 True or False</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - bundle_id - the id of the application to query</p>
<p>用法 driver.is_app_installed(“com.xxxx”)</p>
<p>##<br>22.install_app</p>
<p>install_app(self, app_path):</p>
<p>Install the application found at <code>app_path</code> on the device.</p>
<p>&nbsp;&nbsp;&nbsp; 安装app,app_path为安装包路径</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - app_path - the local or remote path to the application to install</p>
<p>用法 driver.install_app(app_path)</p>
<p>##<br>23.remove_app</p>
<p>remove_app(self, app_id):</p>
<p>Remove the specified application from the device.</p>
<p>&nbsp;&nbsp;&nbsp; 删除app</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - app_id - the application id to be removed</p>
<p>用法 driver.remove_app(“com.xxx.”)</p>
<p>##<br>24.launch_app</p>
<p>launch_app(self):</p>
<p>Start on the device the application specified in the desired capabilities.</p>
<p>启动app</p>
<p>用法 driver.launch_app()</p>
<p>##<br>25.close_app</p>
<p>close_app(self):</p>
<p>Stop the running application, specified in the desired capabilities, on the device.</p>
<p>关闭app</p>
<p>用法 driver.close_app()</p>
<p>启动和关闭app运行好像会出错</p>
<p>##<br>26. start_activity</p>
<p>start_activity(self, app_package, app_activity, **opts):</p>
<p>Opens an arbitrary activity during a test. If the activity belongs to</p>
<p>&nbsp;&nbsp;&nbsp; another application, that application is started and the activity is opened.</p>
<p>&nbsp;&nbsp;&nbsp; This is an Android-only method.</p>
<p>&nbsp;&nbsp;&nbsp; 在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。</p>
<p>这是一个安卓的方法</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp; - app_package - The package containing the activity to start.</p>
<p>&nbsp;&nbsp;&nbsp; - app_activity - The activity to start.</p>
<p>&nbsp;&nbsp;&nbsp; - app_wait_package - Begin automation after this package starts (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - app_wait_activity - Begin automation after this activity starts (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - intent_action - Intent to start (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - intent_category - Intent category to start (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - intent_flags - Flags to send to the intent (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - optional_intent_arguments - Optional arguments to the intent (optional).</p>
<p>&nbsp;&nbsp;&nbsp; - stop_app_on_reset - Should the app be stopped on reset (optional)?</p>
<p>用法 driver.start_activity(app_package, app_activity)</p>
<p>##<br>27.lock</p>
<p>lock(self, seconds):</p>
<p>Lock the device for a certain period of time. iOS only.</p>
<p>&nbsp;&nbsp;&nbsp; 锁屏一段时间&nbsp; iOS专有</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - the duration to lock the device, in seconds</p>
<p>用法 driver.lock()</p>
<p>28.shake</p>
<p>shake(self):</p>
<p>Shake the device.</p>
<p>摇一摇手机</p>
<p>用法 driver.shake()</p>
<p>##<br>29.open_notifications</p>
<p>open_notifications(self):</p>
<p>Open notification shade in Android (API Level 18 and above)</p>
<p>打系统通知栏（仅支持API 18 以上的安卓系统）</p>
<p>用法 driver.open_notifications()</p>
<p>##<br>30.network_connection</p>
<p>network_connection(self):</p>
<p>Returns an integer bitmask specifying the network connection type.</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>返回网络类型&nbsp; 数&#20540;</p>
<p>&nbsp;&nbsp;&nbsp; Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code></p>
<p>用法 driver.network_connection</p>
<p>##<br>31. set_network_connection</p>
<p>set_network_connection(self, connectionType):</p>
<p>Sets the network connection type. Android only.</p>
<p>&nbsp;&nbsp;&nbsp; Possible values:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value (Alias)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Data | Wifi | Airplane Mode</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ————————————————-</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 (None)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp; | 0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 (Airplane Mode)&nbsp; | 0&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp; | 1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 (Wifi only)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp; | 0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 (Data only)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp; | 0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 (All network on) | 1&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp; | 0</p>
<p>&nbsp;&nbsp;&nbsp; These are available through the enumeration appium.webdriver.ConnectionType`</p>
<p>&nbsp;&nbsp;&nbsp; 设置网络类型</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - connectionType - a member of the enum appium.webdriver.ConnectionType</p>
<p>用法&nbsp; 先加载from appium.webdriver.connectiontype import ConnectionType</p>
<p>dr.set_network_connection(ConnectionType.WIFI_ONLY)</p>
<p>ConnectionType的类型有</p>
<p>NO_CONNECTION = 0</p>
<p>AIRPLANE_MODE = 1</p>
<p>WIFI_ONLY = 2</p>
<p>DATA_ONLY = 4</p>
<p>ALL_NETWORK_ON = 6</p>
<p>##<br>32. available_ime_engines</p>
<p>available_ime_engines(self):</p>
<p>Get the available input methods for an Android device. Package and activity are returned (e.g., [‘com.android.inputmethod.latin/.LatinIME’])</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>返回安卓设备可用的输入法</p>
<p>用法print(driver.available_ime_engines)</p>
<p>##<br>33.is_ime_active</p>
<p>is_ime_active(self):</p>
<p>Checks whether the device has IME service active. Returns True/False.</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>检查设备是否有输入法服务活动。返回真/假。</p>
<p>安卓</p>
<p>用法 print(driver.is_ime_active())</p>
<p>##<br>34.activate_ime_engine</p>
<p>activate_ime_engine(self, engine):</p>
<p>Activates the given IME engine on the device.</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>&nbsp;&nbsp;&nbsp; 激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - engine - the package and activity of the IME engine to activate (e.g.,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘com.android.inputmethod.latin/.LatinIME’)</p>
<p>用法 driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</p>
<p>##<br>35.deactivate_ime_engine</p>
<p>deactivate_ime_engine(self):</p>
<p>Deactivates the currently active IME engine on the device.</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>关闭安卓设备当前的输入法</p>
<p>用法 driver.deactivate_ime_engine()</p>
<p>##<br>36.active_ime_engine</p>
<p>active_ime_engine(self):</p>
<p>Returns the activity and package of the currently active IME engine (e.g.,</p>
<p>&nbsp;&nbsp;&nbsp; ‘com.android.inputmethod.latin/.LatinIME’).</p>
<p>&nbsp;&nbsp;&nbsp; Android only.</p>
<p>&nbsp;&nbsp;&nbsp; 返回当前输入法的包名</p>
<p>用法 driver.active_ime_engine</p>
<p>##<br>37. toggle_location_services</p>
<p>toggle_location_services(self):</p>
<p>Toggle the location services on the device. Android only.</p>
<p>打开安卓设备上的位置定位设置</p>
<p>用法 driver.toggle_location_services()</p>
<p>##<br>38.set_location</p>
<p>set_location(self, latitude, longitude, altitude):</p>
<p>Set the location of the device</p>
<p>&nbsp;&nbsp;&nbsp; 设置设备的经纬度</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - latitude纬度 - String or numeric value between -90.0 and 90.00</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - longitude经度 - String or numeric value between -180.0 and 180.0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - altitude海拔高度- String or numeric value</p>
<p>用法 driver.set_location(纬度，经度，高度)</p>
<p>##<br>39.tag_name</p>
<p>tag_name(self):</p>
<p>This element’s <code>tagName</code> property.</p>
<p>返回元素的tagName属性</p>
<p>经实践返回的是class name</p>
<p>用法 element.tag_name()</p>
<p>##<br>40.text</p>
<p>text(self):</p>
<p>The text of the element.</p>
<p>&nbsp;&nbsp;&nbsp; 返回元素的文本&#20540;</p>
<p>用法 element.text()</p>
<p>##<br>41.click</p>
<p>click(self):</p>
<p>Clicks the element.</p>
<p>&nbsp; 点击元素</p>
<p>用法 element.click()</p>
<p>##<br>42.submit</p>
<p>submit(self):</p>
<p>Submits a form.</p>
<p>&nbsp;&nbsp;&nbsp; 提交表单</p>
<p>用法 暂无</p>
<p>##<br>43.clear</p>
<p>clear(self):</p>
<p>Clears the text if it’s a text entry element.</p>
<p>&nbsp;&nbsp;&nbsp; 清除输入的内容</p>
<p>用法 element.clear()</p>
<p>##<br>44.get_attribute</p>
<p>get_attribute(self, name):</p>
<p>详见@chenhengjie123&nbsp;的超级链接</p>
<p>Gets the given attribute or property of the element.</p>
<p>1、获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是</p>
<p>&nbsp;content-desc （content-desc 为空时会返回 text 属性&#20540;）</p>
<p>2、get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的</p>
<p>（此处的名称均为使用 get_attribute 时使用的属性名称）：</p>
<p>可获取的：</p>
<p>字符串类型：</p>
<p>name(返回 content-desc 或 text)</p>
<p>text(返回 text)</p>
<p>className(返回 class，只有 API=&gt;18 才能支持)</p>
<p>resourceId(返回 resource-id，只有 API=&gt;18 才能支持)</p>
<p>&nbsp;&nbsp;&nbsp; This method will first try to return the value of a property with the</p>
<p>&nbsp;&nbsp;&nbsp; given name. If a property with that name doesn’t exist, it returns the</p>
<p>&nbsp;&nbsp;&nbsp; value of the attribute with the same name. If there’s no attribute with</p>
<p>&nbsp;&nbsp;&nbsp; that name, <code>None</code> is returned.</p>
<p>&nbsp;&nbsp;&nbsp; Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,</p>
<p>&nbsp;&nbsp;&nbsp; are returned as booleans.&nbsp; All other non-<code>None</code> values are returned</p>
<p>&nbsp;&nbsp;&nbsp; as strings.&nbsp; For attributes or properties which do not exist, <code>None</code></p>
<p>&nbsp;&nbsp;&nbsp; is returned.</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - Name of the attribute/property to retrieve.</p>
<p>&nbsp;&nbsp;&nbsp; Example::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Check if the &quot;active&quot; CSS class is applied to an element.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</p>
<p>用法 暂无</p>
<p>##<br>45.is_selected</p>
<p>is_selected(self):</p>
<p>Returns whether the element is selected.</p>
<p>&nbsp;&nbsp;&nbsp; Can be used to check if a checkbox or radio button is selected.</p>
<p>返回元素是否选择。</p>
<p>可以用来检查一个复选框或单选按钮被选中。</p>
<p>用法 element.is_slected()</p>
<p>##<br>46.is_enabled</p>
<p>is_enabled(self):</p>
<p>Returns whether the element is enabled.</p>
<p>&nbsp;&nbsp;&nbsp; 返回元素是否可用True of False</p>
<p>用法 element.is_enabled()</p>
<p>##<br>47.find_element_by_id</p>
<p>find_element_by<em>id(self, id</em>):</p>
<p>Finds element within this element’s children by ID.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素的ID定位元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - id_ - ID of child element to locate.</p>
<p>用法 driver. find_element_by_id(“id”)</p>
<p>##<br>48. find_elements_by_id</p>
<p>find_elements_by<em>id(self, id</em>):</p>
<p>Finds a list of elements within this element’s children by ID.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素ID定位,含有该属性的所有元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - id_ - Id of child element to find.</p>
<p>用法 driver. find_elements_by_id(“id”)</p>
<p>##<br>49. find_element_by_name</p>
<p>find_element_by_name(self, name):</p>
<p>Finds element within this element’s children by name.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 通过元素Name定位（元素的名称属性text）</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - name property of the element to find.</p>
<p>用法 driver.find_element_by_name(“name”)</p>
<p>##<br>50. find_elements_by_name</p>
<p>find_elements_by_name(self, name):</p>
<p>Finds a list of elements within this element’s children by name.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素Name定位（元素的名称属性text），含有该属性的所有元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - name property to search for.</p>
<p>用法 driver.find_element_by_name(“name”)</p>
<p>##<br>51. find_element_by_link_text</p>
<p>find_element_by_link_text(self, link_text):</p>
<p>Finds element within this element’s children by visible link text.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素可见链接文本定位</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - link_text - Link text string to search for.</p>
<p>用法 driver.find_element_by_link_text(“text”)</p>
<p>##<br>52. find_elements_by_link_text</p>
<p>find_element_by_link_text(self, link_text):</p>
<p>&nbsp;Finds a list of elements within this element’s children by visible link text</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素可见链接文本定位,含有该属性的所有元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - link_text - Link text string to search for.</p>
<p>用法 driver.find_elements_by_link_text(“text”)</p>
<p>##<br>53. find_element_by_partial_link_text</p>
<p>find_element_by_partial_link_text(self, link_text):</p>
<p>Finds element within this element’s children by partially visible link text.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素部分可见链接文本定位</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - link_text - Link text string to search for.</p>
<p>driver. find_element_by_partial_link_text(“text”)</p>
<p>##<br>54. find_elements_by_partial_link_text</p>
<p>find_elements_by_partial_link_text(self, link_text):</p>
<p>Finds a list of elements within this element’s children by link text.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素部分可见链接文本定位,含有该属性的所有元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - link_text - Link text string to search for.</p>
<p>driver. find_elements_by_partial_link_text(“text”)</p>
<p>##<br>55. find_element_by_tag_name</p>
<p>find_element_by_tag_name(self, name):</p>
<p>Finds element within this element’s children by tag name.</p>
<p>&nbsp;&nbsp;&nbsp; 通过查找html的标签名称定位元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - name of html tag (eg: h1, a, span)</p>
<p>用法&nbsp; driver.find_element_by_tag_name(“name”)</p>
<p>##<br>56. find_elements_by_tag_name</p>
<p>find_elements_by_tag_name(self, name):</p>
<p>Finds a list of elements within this element’s children by tag name.</p>
<p>&nbsp;&nbsp; 通过查找html的标签名称定位所有元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - name of html tag (eg: h1, a, span)</p>
<p>用法driver.find_elements_by_tag_name(“name”)</p>
<p>##<br>57. find_element_by_xpath</p>
<p>find_element_by_xpath(self, xpath):</p>
<p>Finds element by xpath.</p>
<p>&nbsp;&nbsp;&nbsp; 通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="external">http://www.w3school.com.cn/xpath/</a></p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpath - xpath of element to locate.&nbsp; &quot;//input[@class=’myelement’]&quot;</p>
<p>&nbsp;&nbsp;&nbsp; Note: The base path will be relative to this element’s location.</p>
<p>&nbsp;&nbsp;&nbsp; This will select the first link under this element.</p>
<p>&nbsp;&nbsp;&nbsp; ::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myelement.find_elements_by_xpath(&quot;.//a&quot;)</p>
<p>&nbsp;&nbsp;&nbsp; However, this will select the first link on the page.</p>
<p>&nbsp;&nbsp;&nbsp; ::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myelement.find_elements_by_xpath(&quot;//a&quot;)</p>
<p>用法 find_element_by_xpath(“//*”)</p>
<p>##<br>58. find_elements_by_xpath</p>
<p>find_elements_by_xpath(self, xpath):</p>
<p>Finds elements within the element by xpath.</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xpath - xpath locator string.</p>
<p>&nbsp;&nbsp;&nbsp; Note: The base path will be relative to this element’s location.</p>
<p>&nbsp;&nbsp;&nbsp; This will select all links under this element.</p>
<p>&nbsp;&nbsp;&nbsp; ::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myelement.find_elements_by_xpath(&quot;.//a&quot;)</p>
<p>&nbsp;&nbsp;&nbsp; However, this will select all links in the page itself.</p>
<p>&nbsp;&nbsp;&nbsp; ::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myelement.find_elements_by_xpath(&quot;//a&quot;)</p>
<p>用法find_elements_by_xpath(“//*”)</p>
<p>##<br>59. find_element_by_class_name</p>
<p>find_element_by_class_name(self, name):</p>
<p>Finds element within this element’s children by class name.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素class name属性定位元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - class name to search for.</p>
<p>用法 driver. find_element_by_class_name(“android.widget.LinearLayout”)</p>
<p>##<br>60. find_elements_by_class_name</p>
<p>find_elements_by_class_name(self, name):</p>
<p>Finds a list of elements within this element’s children by class name.</p>
<p>&nbsp;&nbsp;&nbsp; 通过元素class name属性定位所有含有该属性的元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name - class name to search for.</p>
<p>用法 driver. find_elements_by_class_name(“android.widget.LinearLayout”)</p>
<p>##<br>61. find_element_by_css_selector</p>
<p>find_element_by_css_selector(self, css_selector):</p>
<p>Finds element within this element’s children by CSS selector.</p>
<p>&nbsp;&nbsp;&nbsp; 通过CSS选择器定位元素</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - css_selector - CSS selctor string, ex: ‘a.nav#home’</p>
<p>##<br>62.send_keys</p>
<p>send_keys(self, *value):</p>
<p>Simulates typing into the element.</p>
<p>&nbsp;&nbsp;&nbsp; 在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - value - A string for typing, or setting form fields.&nbsp; For setting</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file inputs, this could be a local file path.</p>
<p>&nbsp;&nbsp;&nbsp; Use this to send simple key events or to fill out form fields::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; form_textfield = driver.find_element_by_name(‘username’)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; form_textfield.send_keys(&quot;admin&quot;)</p>
<p>&nbsp;&nbsp;&nbsp; This can also be used to set file inputs.</p>
<p>&nbsp;&nbsp;&nbsp; ::</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_input = driver.find_element_by_name(‘profilePic’)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Generally it’s better to wrap the file path in one of the methods</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in os.path to return the actual path to support cross OS testing.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</p>
<p>driver.element.send_keys(“中英”)</p>
<p>##<br>63. is_displayed</p>
<p>is_displayed(self):</p>
<p>Whether the element is visible to a user.&nbsp;&nbsp;&nbsp;</p>
<p>此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类&#20284;功能不是太确定）</p>
<p>这一项都会返回 False</p>
<p>用法 driver.element.is_displayed()</p>
<p>##<br>64. location_once_scrolled_into_view</p>
<p>location_once_scrolled_into_view(self):</p>
<p>&nbsp;&quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover</p>
<p>&nbsp;&nbsp;&nbsp; where on the screen an element is so that we can click it. This method</p>
<p>&nbsp;&nbsp;&nbsp; should cause the element to be scrolled into view.</p>
<p>&nbsp;&nbsp;&nbsp; Returns the top lefthand corner location on the screen, or <code>None</code> if</p>
<p>&nbsp;&nbsp;&nbsp; the element is not visible.</p>
<p>&nbsp;&nbsp;&nbsp; 暂不知道用法</p>
<p>&nbsp;&nbsp;&nbsp; &quot;&quot;&quot;</p>
<p>##<br>65.size</p>
<p>size(self):</p>
<p>The size of the element.</p>
<p>获取元素的大小（高和宽）</p>
<p>new_size[&quot;height&quot;] = size[&quot;height&quot;]</p>
<p>new_size[&quot;width&quot;] = size[&quot;width&quot;]</p>
<p>用法 driver.element.size</p>
<p>##<br>66. value_of_css_property</p>
<p>value_of_css_property(self, property_name):</p>
<p>The value of a CSS property.</p>
<p>CSS属性</p>
<p>用法 暂不知</p>
<p>##<br>67.location</p>
<p>location(self):</p>
<p>The location of the element in the renderable canvas.</p>
<p>&nbsp;&nbsp;&nbsp; 获取元素左上角的坐标</p>
<p>用法 driver.element.location</p>
<p>‘’’返回element的x坐标, int类型’’’</p>
<p>driver.element.location.get(‘x’)</p>
<p>‘’’返回element的y坐标, int类型’’’</p>
<p>driver.element.location.get(‘y’)</p>
<p>##<br>68.rect</p>
<p>rect(self):</p>
<p>A dictionary with the size and location of the element.</p>
<p>&nbsp;&nbsp;&nbsp; 元素的大小和位置的字典</p>
<p>##<br>69. screenshot_as_base64</p>
<p>screenshot_as_base64(self):</p>
<p>&nbsp;&nbsp;&nbsp; Gets the screenshot of the current element as a base64 encoded string.</p>
<p>&nbsp;&nbsp;&nbsp; 获取当前元素的截图为Base64编码的字符串</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img_b64 = element.screenshot_as_base64</p>
<p>##<br>70.execute_script</p>
<p>execute_script(self, script, *args):</p>
<p>&nbsp;&nbsp;&nbsp; Synchronously Executes JavaScript in the current window/frame.</p>
<p>在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - script: The JavaScript to execute.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - *args: Any applicable arguments for your JavaScript.</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.execute_script(‘document.title’)</p>
<p>##<br>71.execute_async_script</p>
<p>execute_async_script(self, script, *args):</p>
<p>&nbsp;&nbsp;&nbsp; Asynchronously Executes JavaScript in the current window/frame.</p>
<p>插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行</p>
<p>&nbsp;&nbsp;&nbsp; :Args:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - script: The JavaScript to execute.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; - *args: Any applicable arguments for your JavaScript.</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.execute_async_script(‘document.title’)</p>
<p>##<br>72.current_url</p>
<p>current_url(self):</p>
<p>&nbsp;&nbsp;&nbsp; Gets the URL of the current page.</p>
<p>&nbsp;&nbsp;&nbsp; 获取当前页面的网址。</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.current_url</p>
<p>用法 driver.current_url</p>
<p>##<br>73. page_source</p>
<p>page_source(self):</p>
<p>&nbsp;&nbsp;&nbsp; Gets the source of the current page.</p>
<p>&nbsp;&nbsp;&nbsp; 获取当前页面的源。</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.page_source</p>
<p>##<br>74.close</p>
<p>close(self):</p>
<p>&nbsp;&nbsp;&nbsp; Closes the current window.</p>
<p>&nbsp;&nbsp;&nbsp; 关闭当前窗口</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver.close()</p>
<p>##<br>75.quit</p>
<p>quit(self):</p>
<p>&nbsp;&nbsp;&nbsp; Quits the driver and closes every associated window.</p>
<p>&nbsp;&nbsp;&nbsp; 退出脚本运行并关闭每个相关的窗口连接</p>
<p>&nbsp;&nbsp;&nbsp; :Usage:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;driver.quit()</p>
]]></content>
      
        <categories>
            
            <category> Appium </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 移动端测试 </tag>
            
            <tag> Appium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[转]提高软件测试能力的建议]]></title>
      <url>/2017/06/30/%E8%BD%AC-%E6%8F%90%E9%AB%98%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%83%BD%E5%8A%9B%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>&nbsp; 我起初准备自己写10条建议给刚入门的软件测试员们。但之后我看了lolcats/icanhascheezburger 上的名人Ben Huh的一段演讲。Ben指出，有了互联网，信息成了免费资源，但组织，编辑，以及表达却都需要技巧。受Ben和cheezburger网站的启发，我请求60名成功的软件测试工程师每人为刚入门的测试人员提出三条建议。其中的40多名答复了我，使我最终有了一个长达100条的建议列表。</p>
<p>&nbsp;&nbsp;&nbsp; 出于保护他们的隐私，我不会原封不动的把这些建议罗列出来。但是有趣的是，我发现他们的建议中有很多共同的地方，而所有这些建议加起来要比我原先自己想到的好得多了。</p>
<a id="more"></a>
<p>我把这些我搜集的建议总结成以下19项：</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">1. 想客户之所想</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在测试的过程中时刻想着用户。培养自己对用户需求的共鸣。和用户沟通并且观察他们怎们样使用你的软件。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">2. 多读Bug</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你和一个团队的软件测试工程师一起工作，那么请阅读 他们每天发的Bug， 特别是那些针对你的测试部分的Bug 。你可以从别人如何找到Bug中学到很多东西。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">3. 多读代码</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找到你测试的那部分功能的代码。虽然写代码并不是你的事，但是读那些代码常常会帮助你找到潜在的边际情况和软件缺陷。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">4. 为你发现的Bug而骄傲</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;促成一个软件Bug的修复是从写好Bug标题和描述开始的。我每次发完一个Bug都会把这个Bug重读一遍以确保它是合理的并提供恰倒好处的细节。如果一些重要的Bug 没有被纠正，要追根究底，确保决定和利弊权衡是正确的。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">5. 参加软件功能的设计</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软代码编写之前，在仍有可能有大的设计变更的时候，积极参加软件的计划阶段，这会帮助你了解正被考虑的折衷和权衡。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">6. 设计你的测试</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是寻找边界&#20540;，运用组合技术，画图表，或创建测试模型，把你的想法放进你的测试设计中总是有用的。在试探性测试的时候，有意识地去交替你的测试计划和产品学习。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">7. 了解你测试的功能</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管你测试的是那一块功能，你应该了解它的设计，它的局限性，别人发现的Bug，代码的变动，以及它和其它功能间的交互关系。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">8. 和别人合作测试你负责的部分</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和有不同专长的人一起测试你的功能模块，一起讨论测试的点子并且征询他们的反馈意见。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">9. 学习你测试的软件</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你只是测试一个软件中的很小一部分，成为其它新功能和整个软件的专家都会帮助你成为一个更好的测试工程师。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">10. 培养和开发人员的良好关系</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试工作有时候是对抗性的，以致很容易使有些与你共事的人在做决定时忽略你的意见。与修复Bug的开发人员建立坚实的关系对了解最新进展和促成Bug的修复会有裨益。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">11. 扩大你的领域和人际网络</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;成功的人都有一个的坚实可信的交际圈。他们可以从中得到他们需要的专业知识和建议。不断在你的公司内部和外部结交新朋友并发展专业领域的联系。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">12. 寻找良师或榜样</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我和许多出色的测试工程师一起工作过，并且从他们那里学到了很多东西。为了提高你的测试技能，你应该寻找“顾问”与他们见面或者榜样向他们效仿。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">13. 保持自省</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试工程师善于发现软件的缺陷。如果把这种敏锐运用到自己身上，我们一定能更有效的发现自身的不足之处。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">14. 管理你的时间</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的时间很容易被大块的工作和不断的会议所占据，导致我们没有时间去学习，去深挖更多的Bug，甚至没有时间保持健康的生活状态。为了避免透支，你需要学习如何管理你的时间。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">15. 明智地选择测试自动化</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动化测试可能缺乏熟练测试人员的那种“余光视力”。不正确的自动化有时会变成一推庞大而难以维护的代码，并且对衡量软件质量没有什么实际意思。但是精心设计的自动化测试有助于及早发现软件缺陷。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">16. 提高你的编程能力</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我遇到过一些很有天赋的测试人员，他们倾向于不去写代码。这有一定道理。就像电影评论家在变得挑剔而富有陈见后不会去考虑电影观众的喜恶一样，在我充当编程员的角色时，我想的就不再和用户一样了。但是编程还是一项有价&#20540;的技能，他能帮助你更好地阅读代码，理解产品的内在，同时帮助你写一些小工具使得平淡反复的工作变得简单。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">17. 参加Bug的审阅 （Triage）</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在产品发布前的最后一些日子里，Bug审阅组开会决定哪一些Bug应该修复，哪一些应该留到以后的版本去修复。如果你通常不在这个会议的邀请名单中，那么去主动要求参加。你会看到在测试员信誉，用户影响和已知风险等因素间做出折衷决定的过程。这将会是一种非常有趣的经历。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">18. 不断学习</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是“软技能”，比如公开演讲， 或者编程语言，亦或新的测试技术，成功的测试工程师总是会从繁忙中抽出时间来坚持学习。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; color:rgb(255,76,0)"><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important">19. 爱你所做的事，并把它做好</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不能承担放弃当前工作的代价，那么就学着去热爱它。测试人员有时会变得嫉世愤俗，尤其是在困难的发布周期中。享受工作并且不满足于仅仅完成计划内目标的人才会成为优秀的测试工程师。</p>
<p><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; font-size:14px">转载：<a href="http://www.cnblogs.com/stbchina/archive/2010/05/19/Cheezburgers-and-Testing-Advice.html" target="_blank" rel="external">http://www.cnblogs.com/stbchina/archive/2010/05/19/Cheezburgers-and-Testing-Advice.html</a></span></p>
<div><span style="margin:0px; padding:0px; max-width:100%; word-wrap:break-word!important; font-size:14px"><br><br></span></div>

]]></content>
      
        <categories>
            
            <category> 测试经验文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 测试能力提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[转]软件测试常见风险分析]]></title>
      <url>/2017/06/27/%E8%BD%AC-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><span style="font-size:18px"><span style="color:#009900"><span style="font-family:&quot;Helvetica Neue&quot;">在测试工作中，主要的</span><strong><span style="font-family:Helvetica Neue">风险表现</span></strong><span style="font-family:&quot;Helvetica Neue&quot;">有以下几点：</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>1）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">需求风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>对软件需求理解不准确，导致测试范围存在误差，遗漏部分需求或者执行了错误的测试方式；另外需求变更导致测试用例变更，同步时存在误差。</span></span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>2）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">测试用例风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>测试用例设计不完整，忽视了边界条件、异常处理等情况，用例没有完全覆盖需求；测试用例没有得到全部执行，有些用例被有意或者无意的遗漏；</span></span></span><br><a id="more"></a><br><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>3）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">缺陷风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。某些缺陷偶发，难以重现，容易被遗漏；</span></span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>4）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">代码质量风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>软件代码质量差，导致缺陷较多，容易出现测试的遗漏；</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>5）测试环境风险。有些情况下测试环境与生产环境不能完全一致，导致测试结果存在误差；</span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-size:18px"></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>6）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">测试技术风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>某些项目存在技术难度，测试能力和水平导致测试进展缓慢，项目延期；</span></span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>7）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">回归测试风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>回归测试一般不运行全部测试用例，可能存在测试不完全；</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"></span></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>8）沟通协调风险。测试过程中涉及的角色较多，存在不同人员、角色之间的沟通、协作，难免存在误解、沟通不畅的情况，导致项目延期；</span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-size:18px"></span></span></p>
<p></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">（</span>9）</span><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">其它不可预计风险</span></span></strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">。</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>一些突发状况、不可抗力等也构成风险因素，且难以预估和避免。</span></span></span></p>
<p><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-size:18px; color:rgb(62,62,62)"><span style="font-family:Helvetica Neue"><span style="white-space:pre"></span>以上是测试过程中可能发生的风险，其中有的风险是难以避免的，如缺陷风险等。有的风险从理论上可以避免，但实际操作过程中出于时间和成本的考虑，也难以完全回避，如回归测试风险等。</span></span><span style="font-size:18px"><strong><span style="color:rgb(62,62,62)"><span style="font-family:Helvetica Neue">对于难以避免的风险，我们的目标是将风险降到最低水平。</span></span></strong></span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
]]></content>
      
        <categories>
            
            <category> 测试经验文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 风险分析 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
